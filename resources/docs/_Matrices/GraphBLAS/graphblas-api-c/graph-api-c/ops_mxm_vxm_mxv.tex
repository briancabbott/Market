%-----------------------------------------------------------------------------
\subsection{{\sf mxm}: Matrix-matrix multiply}

Multiplies a matrix with another matrix on a semiring. The result is a matrix.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_mxm(GrB_Matrix             C,
                         const GrB_Matrix       Mask,
                         const GrB_BinaryOp     accum,
                         const GrB_Semiring     op,
                         const GrB_Matrix       A,
                         const GrB_Matrix       B,
                         const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    ({\sf INOUT}) An existing GraphBLAS matrix. On input,
    the matrix provides values that may be accumulated with the result of the
    matrix product.  On output, the matrix holds the results of the
    operation.

    \item[{\sf Mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output matrix {\sf C}. The 
    mask dimensions must match those of the matrix {\sf C}. If the 
    {\sf GrB\_STRUCTURE} descriptor is {\em not} set for the mask, the domain 
    of the {\sf Mask} matrix must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    mask is desired (\ie, a mask that is all {\sf true} with the dimensions of {\sf C}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf C} entries.
    %: ${\sf accum} = \langle \bDout({\sf accum}),\bDin1({\sf accum}),
    %\bDin2({\sf accum}), \odot \rangle$. 
    If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]   ({\sf IN}) The semiring used in the matrix-matrix
    multiply.
    %: ${\sf op}=\langle \bDout({\sf op}),\bDin1({\sf op}),\bDin2({\sf op}),\oplus,\otimes,0 \rangle$.

    \item[{\sf A}]    ({\sf IN}) The GraphBLAS matrix holding the values
    for the left-hand matrix in the multiplication.

    \item[{\sf B}]    ({\sf IN}) The GraphBLAS matrix holding the values for
    the right-hand matrix in the multiplication.

    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\
    
    \hspace*{-2em}\begin{tabular}{lllp{2.7in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C}
        is cleared (all elements removed) before the result is stored in it.\\

        {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_STRUCTURE}   & The write mask is
        constructed from the structure (pattern of stored values) of the input
        {\sf Mask} matrix. The stored values are not examined.\\

        {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_COMP}   & Use the
        complement of {\sf Mask}. \\

        {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Use transpose of {\sf A}
        for the operation. \\

        {\sf B}    & {\sf GrB\_INP1} & {\sf GrB\_TRAN}   & Use transpose of {\sf B}
        for the operation. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output matrix {\sf C} is ready to be used in the next method of
    the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for the operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects 
    has not been initialized by a call to {\sf new} (or {\sf Matrix\_dup} for matrix
    parameters).

    \item[{\sf GrB\_DIMENSION\_MISMATCH}] Mask and/or matrix
    dimensions are incompatible.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various matrices are
    incompatible with the corresponding domains of the semiring or
    accumulation operator, or the mask's domain is not compatible with {\sf bool}
    (in the case where {\sf desc[GrB\_MASK].GrB\_STRUCTURE} is not set).
\end{itemize}

\paragraph{Description}

{\sf GrB\_mxm} computes the matrix product ${\sf C} = {\sf
A} \oplus . \otimes {\sf B}$ or, if an optional binary accumulation
operator ($\odot$) is provided, ${\sf C} = {\sf C} \odot
\left({\sf A} \oplus . \otimes {\sf B}\right)$ (where matrices {\sf A}
and {\sf B} can be optionally transposed).  Logically, this operation
occurs in three steps:
\begin{enumerate}[leftmargin=0.85in]
\item[\bf Setup] The internal matrices and mask used in the computation are formed and their 
domains and dimensions are tested for compatibility.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output matrix, possibly under control of a mask.
\end{enumerate}

Up to four argument matrices are used in the {\sf GrB\_mxm} operation:
\begin{enumerate}
	\item ${\sf C} = \langle \bold{D}({\sf C}),\bold{nrows}({\sf C}),\bold{ncols}({\sf C}),\bold{L}({\sf C}) = \{(i,j,C_{ij}) \} \rangle$
	\item ${\sf Mask} = \langle \bold{D}({\sf Mask}),\bold{nrows}({\sf Mask}),\bold{ncols}({\sf Mask}),\bold{L}({\sf Mask}) = \{(i,j,M_{ij}) \} \rangle$ (optional)
	\item ${\sf A} = \langle \bold{D}({\sf A}),\bold{nrows}({\sf A}), \bold{ncols}({\sf A}),\bold{L}({\sf A}) = \{(i,j,A_{ij}) \} \rangle$
	\item ${\sf B} = \langle \bold{D}({\sf B}),\bold{nrows}({\sf B}), \bold{ncols}({\sf B}),\bold{L}({\sf B}) = \{(i,j,B_{ij}) \} \rangle$
\end{enumerate}

The argument matrices, the semiring, and the accumulation operator (if provided) 
are tested for domain compatibility as follows:
\begin{enumerate}
	\item If {\sf Mask} is not {\sf GrB\_NULL}, and ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$
    is not set, then $\bold{D}({\sf Mask})$ must be from one of the pre-defined types of 
    Table~\ref{Tab:PredefinedTypes}.

	\item $\bold{D}({\sf A})$ must be compatible with $\bDin1({\sf op})$ of the semiring.

	\item $\bold{D}({\sf B})$ must be compatible with $\bDin2({\sf op})$ of the semiring.

	\item $\bold{D}({\sf C})$ must be compatible with $\bDout({\sf op})$ of the semiring.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be
    compatible with $\bDin1({\sf accum})$ and $\bDout({\sf accum})$ of the 
    accumulation operator and $\bDout({\sf op})$ of the semiring must be compatible with 
    $\bDin2({\sf accum})$ of the accumulation operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_mxm} ends and 
the domain mismatch error listed above is returned.

From the argument matrices, the internal matrices and mask used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Matrix $\matrix{\widetilde{C}} \leftarrow {\sf C}$.

	\item Two-dimensional mask, $\matrix{\widetilde{M}}$, is computed from
    argument {\sf Mask} as follows:
	\begin{enumerate}
		\item If ${\sf Mask} = {\sf GrB\_NULL}$, then $\matrix{\widetilde{M}} = 
        \langle \bold{nrows}({\sf C}), \bold{ncols}({\sf C}), \{(i,j), 
        \forall i,j : 0 \leq i <  \bold{nrows}({\sf C}), 0 \leq j < 
        \bold{ncols}({\sf C}) \} \rangle$.

		\item If {\sf Mask} $\ne$ {\sf GrB\_NULL},
        \begin{enumerate}
            \item If ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$ is set, then 
            $\matrix{\widetilde{M}} = \langle \bold{nrows}({\sf Mask}), 
            \bold{ncols}({\sf Mask}), \{(i,j) : (i,j) \in \bold{ind}({\sf Mask}) \} \rangle$,
            \item Otherwise, $\matrix{\widetilde{M}} = \langle \bold{nrows}({\sf Mask}), 
            \bold{ncols}({\sf Mask}), \\ \{(i,j) : (i,j) \in \bold{ind}({\sf Mask}) \wedge 
            ({\sf bool}){\sf Mask}(i,j) = \true\} \rangle$.
        \end{enumerate}

		\item	If ${\sf desc[GrB\_MASK].GrB\_COMP}$ is set, then 
        $\matrix{\widetilde{M}} \leftarrow \neg \matrix{\widetilde{M}}$.
	\end{enumerate}

	\item Matrix $\matrix{\widetilde{A}} \leftarrow
    {\sf desc[GrB\_INP0].GrB\_TRAN} \ ? \ {\sf A}^T : {\sf A}$.

	\item Matrix $\matrix{\widetilde{B}} \leftarrow
    {\sf desc[GrB\_INP1].GrB\_TRAN} \ ? \ {\sf B}^T : {\sf B}$.
\end{enumerate}

The internal matrices and masks are checked for dimension compatibility. The following
conditions must hold:
\begin{enumerate}
	\item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{M}})$.

	\item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{M}})$.

	\item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{A}})$.

	\item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{B}})$.

	\item $\bold{ncols}(\matrix{\widetilde{A}}) = \bold{nrows}(\matrix{\widetilde{B}})$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_mxm} ends and
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can 
optionally exit with {\sf GrB\_SUCCESS} return code and defer any computation 
and/or execution error codes.

We are now ready to carry out the matrix multiplication and any additional 
associated operations.  We describe this in terms of two intermediate matrices:
\begin{itemize}
    \item $\matrix{\widetilde{T}}$: The matrix holding the product of matrices 
    $\matrix{\widetilde{A}}$ and $\matrix{\widetilde{B}}$.
    \item $\matrix{\widetilde{Z}}$: The matrix holding the result after 
    application of the (optional) accumulation operator.
\end{itemize}

The intermediate matrix $\matrix{\widetilde{T}} = \langle
\bDout({\sf op}), \bold{nrows}(\matrix{\widetilde{A}}), \bold{ncols}(\matrix{\widetilde{B}}),
\{(i,j,T_{ij}) : \bold{ind}(\matrix{\widetilde{A}}(i,:)) \cap
\bold{ind}(\matrix{\widetilde{B}}(:,j)) \neq \emptyset \} \rangle$
is created.  The value of each of its elements is computed by 
\[T_{ij} = \bigoplus_{k \in \bold{ind}(\matrix{\widetilde{A}}(i,:)) \cap
\bold{ind}(\matrix{\widetilde{B}}(:,j))} (\matrix{\widetilde{A}}(i,k)
\otimes \matrix{\widetilde{B}}(k,j)),\] where $\oplus$ and $\otimes$
are the additive and multiplicative operators of semiring {\sf op},
respectively.

\input{ops_accum_z_matrix}

\input{ops_mask_replace_matrix}

%-----------------------------------------------------------------------------

\subsection{{\sf vxm}: Vector-matrix multiply}

Multiplies a (row) vector with a matrix on an semiring. The result is a vector.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_vxm(GrB_Vector             w,
                         const GrB_Vector       mask,
                         const GrB_BinaryOp     accum,
                         const GrB_Semiring     op,
                         const GrB_Vector       u, 
                         const GrB_Matrix       A,
                         const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]    ({\sf INOUT}) An existing GraphBLAS vector.  On input,
    the vector provides values that may be accumulated with the result of the
    vector-matrix product.  On output, this vector holds the results of the
    operation.

    \item[{\sf mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output vector {\sf w}. The 
    mask dimensions must match those of the vector {\sf w}. If the 
    {\sf GrB\_STRUCTURE} descriptor is {\em not} set for the mask, the domain of the
    {\sf mask} vector must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    mask is desired (\ie, a mask that is all {\sf true} with the dimensions of {\sf w}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf w} entries.
    %: ${\sf accum} = \langle \bDout({\sf accum}),\bDin1({\sf accum}),
    %\bDin2({\sf accum}), \odot \rangle$. 
    If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]   ({\sf IN}) Semiring used in the vector-matrix
    multiply.
    %: ${\sf op}=\langle \bDout({\sf op}),\bDin1({\sf op}),\bDin2({\sf op}),\oplus,\otimes,0 \rangle$.

    \item[{\sf u}]    ({\sf IN}) The GraphBLAS vector holding the values for
    the left-hand vector in the multiplication.

    \item[{\sf A}]    ({\sf IN}) The GraphBLAS matrix holding the values
    for the right-hand matrix in the multiplication.

    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \hspace*{-2em}\begin{tabular}{lllp{2.7in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w}
        is cleared (all elements removed) before the result is stored in it.\\

        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_STRUCTURE}   & The write mask is
        constructed from the structure (pattern of stored values) of the input
        {\sf mask} vector. The stored values are not examined.\\

        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_COMP}   & Use the
        complement of {\sf mask}. \\

        {\sf A}    & {\sf GrB\_INP1} & {\sf GrB\_TRAN}   & Use transpose of {\sf A}
        for the operation. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output vector {\sf w} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for the operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects 
    has not been initialized by a call to {\sf new} (or {\sf dup} for matrix or
    vector parameters).

    \item[{\sf GrB\_DIMENSION\_MISMATCH}] Mask, vector, and/or matrix 
    dimensions are incompatible.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various vectors/matrices are
    incompatible with the corresponding domains of the semiring or
    accumulation operator, or the mask's domain is not compatible with {\sf bool}
    (in the case where {\sf desc[GrB\_MASK].GrB\_STRUCTURE} is not set).
\end{itemize}

\paragraph{Description}

{\sf GrB\_vxm} computes the vector-matrix product ${\sf w}^T = {\sf
u}^T \oplus . \otimes {\sf A}$, or, if an optional binary accumulation
operator ($\odot$) is provided, ${\sf w}^T = {\sf w}^T \odot
\left({\sf u}^T \oplus . \otimes {\sf A}\right)$ (where matrix {\sf A}
 can be optionally transposed).  Logically, this operation
occurs in three steps:
\begin{enumerate}[leftmargin=0.85in]
\item[\bf Setup] The internal vectors, matrices and mask used in the computation are formed and their domains/dimensions are tested for compatibility.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output vector, possibly under control of a mask.
\end{enumerate}

Up to four argument vectors or matrices are used in the {\sf GrB\_vxm} operation:
\begin{enumerate}
	\item ${\sf w} = \langle \bold{D}({\sf w}),\bold{size}({\sf w}),\bold{L}({\sf w}) = \{(i,w_i) \} \rangle$
	\item ${\sf mask} = \langle \bold{D}({\sf mask}),\bold{size}({\sf mask}),\bold{L}({\sf mask}) = \{(i,m_i) \} \rangle$ (optional)
	\item ${\sf u} = \langle \bold{D}({\sf u}),\bold{size}({\sf u}),\bold{L}({\sf u}) = \{(i,u_i) \} \rangle$
	\item ${\sf A} = \langle \bold{D}({\sf A}),\bold{nrows}({\sf A}), \bold{ncols}({\sf A}),\bold{L}({\sf A}) = \{(i,j,A_{ij}) \} \rangle$
\end{enumerate}

The argument matrices, vectors, the semiring, and the accumulation operator (if provided) 
are tested for domain compatibility as follows:
\begin{enumerate}
	\item If {\sf mask} is not {\sf GrB\_NULL}, and ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$
    is not set, then $\bold{D}({\sf mask})$ must be from one of the pre-defined types of 
    Table~\ref{Tab:PredefinedTypes}.

	\item $\bold{D}({\sf u})$ must be compatible with $\bDin1({\sf op})$ of the semiring.

	\item $\bold{D}({\sf A})$ must be compatible with $\bDin2({\sf op})$ of the semiring.

	\item $\bold{D}({\sf w})$ must be compatible with $\bDout({\sf op})$ of the semiring.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be compatible with $\bDin1({\sf accum})$ and $\bDout({\sf accum})$ of the 
	accumulation operator and $\bDout({\sf op})$ of the semiring must be compatible with $\bDin2({\sf accum})$ of the accumulation operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_vxm} ends and 
the domain mismatch error listed above is returned.

From the argument vectors and matrices, the internal matrices and mask used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Vector $\vector{\widetilde{w}} \leftarrow {\sf w}$.

	\item One-dimensional mask, $\vector{\widetilde{m}}$, is computed from 
    argument {\sf mask} as follows:
	\begin{enumerate}
		\item If ${\sf mask} = {\sf GrB\_NULL}$, then $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf w}), \{i, \ \forall \ i : 0 \leq i < 
        \bold{size}({\sf w}) \} \rangle$.

		\item If {\sf mask} $\ne$ {\sf GrB\_NULL},  
        \begin{enumerate}
            \item If ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$ is set, then
            $\vector{\widetilde{m}} = 
            \langle \bold{size}({\sf mask}), \{i : i \in \bold{ind}({\sf mask}) \} \rangle$,
            \item Otherwise, $\vector{\widetilde{m}} = 
            \langle \bold{size}({\sf mask}), \{i : i \in \bold{ind}({\sf mask}) \wedge
            ({\sf bool}){\sf mask}(i) = \true \} \rangle$.
        \end{enumerate}

		\item	If ${\sf desc[GrB\_MASK].GrB\_COMP}$ is set, then 
        $\vector{\widetilde{m}} \leftarrow \neg \vector{\widetilde{m}}$.
	\end{enumerate}

	\item Vector $\vector{\widetilde{u}} \leftarrow {\sf u}$.

	\item Matrix $\matrix{\widetilde{A}} \leftarrow {\sf desc[GrB\_INP1].GrB\_TRAN} \ ? \ {\sf A}^T : {\sf A}$.
\end{enumerate}

The internal matrices and masks are checked for shape compatibility. The following 
conditions must hold:
\begin{enumerate}
	\item $\bold{size}(\vector{\widetilde{w}}) = \bold{size}(\vector{\widetilde{m}})$.

	\item $\bold{size}(\vector{\widetilde{w}}) = \bold{ncols}(\matrix{\widetilde{A}})$.

	\item $\bold{size}(\vector{\widetilde{u}}) = \bold{nrows}(\matrix{\widetilde{A}})$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_vxm} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can 
optionally exit with {\sf GrB\_SUCCESS} return code and defer any computation 
and/or execution error codes.

We are now ready to carry out the vector-matrix multiplication and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
    \item $\vector{\widetilde{t}}$: The vector holding the product of vector
    $\vector{\widetilde{u}}^T$ and matrix $\matrix{\widetilde{A}}$.
    \item $\vector{\widetilde{z}}$: The vector holding the result after 
    application of the (optional) accumulation operator.
\end{itemize}

The intermediate vector $\vector{\widetilde{t}} = \langle
\bDout({\sf op}), \bold{ncols}(\matrix{\widetilde{A}}),
\{(j,t_j) : \bold{ind}(\vector{\widetilde{u}}) \cap
\bold{ind}(\matrix{\widetilde{A}}(:,j)) \neq \emptyset \} \rangle$
is created.  The value of each of its elements is computed by 
\[t_j = \bigoplus_{k \in \bold{ind}(\vector{\widetilde{u}}) \cap
\bold{ind}(\matrix{\widetilde{A}}(:,j))} (\vector{\widetilde{u}}(k)
\otimes \matrix{\widetilde{A}}(k,j)),\] where $\oplus$ and $\otimes$
are the additive and multiplicative operators of semiring {\sf op},
respectively.

\input{ops_accum_z_vector}

\input{ops_mask_replace_vector}

%-----------------------------------------------------------------------------

\subsection{{\sf mxv}: Matrix-vector multiply}

Multiplies a matrix by a vector on a semiring. The result is a vector.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_mxv(GrB_Vector             w,
                         const GrB_Vector       mask,
                         const GrB_BinaryOp     accum,
                         const GrB_Semiring     op,
                         const GrB_Matrix       A,
                         const GrB_Vector       u,
                         const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]    ({\sf INOUT}) An existing GraphBLAS vector.  On input,
    the vector provides values that may be accumulated with the result of the
    matrix-vector product.  On output, this vector holds the results of the
    operation.

    \item[{\sf mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output vector {\sf w}. The 
    mask dimensions must match those of the vector {\sf w}. If the 
    {\sf GrB\_STRUCTURE} descriptor is {\em not} set for the mask, the domain of the
    {\sf mask} vector must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    mask is desired (\ie, a mask that is all {\sf true} with the dimensions of {\sf w}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf w} entries.
    %: ${\sf accum} = \langle \bDout({\sf accum}),\bDin1({\sf accum}),
    %\bDin2({\sf accum}), \odot \rangle$. 
    If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]   ({\sf IN}) Semiring used in the vector-matrix
    multiply.
    %: ${\sf op}=\langle \bDout({\sf op}),\bDin1({\sf op}),\bDin2({\sf op}),\oplus,\otimes,0 \rangle$.

    \item[{\sf A}]    ({\sf IN}) The GraphBLAS matrix holding the values
    for the left-hand matrix in the multiplication.

    \item[{\sf u}]    ({\sf IN}) The GraphBLAS vector holding the values for
    the right-hand vector in the multiplication.

    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \hspace*{-2em}\begin{tabular}{lllp{2.7in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w}
        is cleared (all elements removed) before the result is stored in it.\\

        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_STRUCTURE}   & The write mask is
        constructed from the structure (pattern of stored values) of the input
        {\sf mask} vector. The stored values are not examined.\\

        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_COMP}   & Use the
        complement of {\sf mask}. \\

        {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Use transpose of {\sf A}
        for the operation. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output vector {\sf w} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for the operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects 
    has not been initialized by a call to {\sf new} (or {\sf dup} for matrix or
    vector parameters).

    \item[{\sf GrB\_DIMENSION\_MISMATCH}] Mask, vector, and/or matrix 
    dimensions are incompatible.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various vectors/matrices are
    incompatible with the corresponding domains of the semiring or
    accumulation operator, or the mask's domain is not compatible with {\sf bool}
    (in the case where {\sf desc[GrB\_MASK].GrB\_STRUCTURE} is not set).
\end{itemize}

\paragraph{Description}

{\sf GrB\_mxv} computes the matrix-vector product ${\sf w} = {\sf A}
\oplus . \otimes {\sf u}$, or, if an optional binary accumulation
operator ($\odot$) is provided, ${\sf w} = {\sf w} \odot \left({\sf A}
\oplus . \otimes {\sf u}\right)$ (where matrix {\sf A}
 can be optionally transposed).  Logically, this operation
occurs in three steps:
\begin{enumerate}[leftmargin=0.85in]
\item[\bf Setup] The internal vectors, matrices and mask used in the computation are formed and their domains/dimensions are tested for compatibility.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output vector, possibly under control of a mask.
\end{enumerate}

Up to four argument vectors or matrices are used in the {\sf GrB\_mxv} operation:
\begin{enumerate}
	\item ${\sf w} = \langle \bold{D}({\sf w}),\bold{size}({\sf w}),\bold{L}({\sf w}) = \{(i,w_i) \} \rangle$
	\item ${\sf mask} = \langle \bold{D}({\sf mask}),\bold{size}({\sf mask}),\bold{L}({\sf mask}) = \{(i,m_i) \} \rangle$ (optional)
	\item ${\sf A} = \langle \bold{D}({\sf A}),\bold{nrows}({\sf A}), \bold{ncols}({\sf A}),\bold{L}({\sf A}) = \{(i,j,A_{ij}) \} \rangle$
	\item ${\sf u} = \langle \bold{D}({\sf u}),\bold{size}({\sf u}),\bold{L}({\sf u}) = \{(i,u_i) \} \rangle$
\end{enumerate}

The argument matrices, vectors, the semiring, and the accumulation operator (if provided) 
are tested for domain compatibility as follows:
\begin{enumerate}
	\item If {\sf mask} is not {\sf GrB\_NULL}, and ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$
    is not set, then $\bold{D}({\sf mask})$ must be from one of the pre-defined types of 
    Table~\ref{Tab:PredefinedTypes}.

	\item $\bold{D}({\sf A})$ must be compatible with $\bDin1({\sf op})$ of the semiring.

	\item $\bold{D}({\sf u})$ must be compatible with $\bDin2({\sf op})$ of the semiring.

	\item $\bold{D}({\sf w})$ must be compatible with $\bDout({\sf op})$ of the semiring.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be compatible with $\bDin1({\sf accum})$ and $\bDout({\sf accum})$ of the 
	accumulation operator and $\bDout({\sf op})$ of the semiring must be compatible with $\bDin2({\sf accum})$ of the accumulation operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_mxv} ends and 
the domain mismatch error listed above is returned.

From the argument vectors and matrices, the internal matrices and mask used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Vector $\vector{\widetilde{w}} \leftarrow {\sf w}$.

	\item One-dimensional mask, $\vector{\widetilde{m}}$, is computed from 
    argument {\sf mask} as follows:
	\begin{enumerate}
		\item If ${\sf mask} = {\sf GrB\_NULL}$, then $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf w}), \{i, \ \forall \ i : 0 \leq i < 
        \bold{size}({\sf w}) \} \rangle$.

		\item If {\sf mask} $\ne$ {\sf GrB\_NULL},  
        \begin{enumerate}
            \item If ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$ is set, then
            $\vector{\widetilde{m}} = 
            \langle \bold{size}({\sf mask}), \{i : i \in \bold{ind}({\sf mask}) \} \rangle$,
            \item Otherwise, $\vector{\widetilde{m}} = 
            \langle \bold{size}({\sf mask}), \{i : i \in \bold{ind}({\sf mask}) \wedge
            ({\sf bool}){\sf mask}(i) = \true \} \rangle$.
        \end{enumerate}

		\item	If ${\sf desc[GrB\_MASK].GrB\_COMP}$ is set, then 
        $\vector{\widetilde{m}} \leftarrow \neg \vector{\widetilde{m}}$.
	\end{enumerate}

	\item Matrix $\matrix{\widetilde{A}} \leftarrow {\sf desc[GrB\_INP0].GrB\_TRAN} \ ? \ {\sf A}^T : {\sf A}$.

	\item Vector $\vector{\widetilde{u}} \leftarrow {\sf u}$.
\end{enumerate}

The internal matrices and masks are checked for shape compatibility. The following 
conditions must hold:
\begin{enumerate}
	\item $\bold{size}(\vector{\widetilde{w}}) = \bold{size}(\vector{\widetilde{m}})$.

	\item $\bold{size}(\vector{\widetilde{w}}) = \bold{nrows}(\matrix{\widetilde{A}})$.

	\item $\bold{size}(\vector{\widetilde{u}}) = \bold{ncols}(\matrix{\widetilde{A}})$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_mxv} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can 
optionally exit with {\sf GrB\_SUCCESS} return code and defer any computation 
and/or execution error codes.

We are now ready to carry out the matrix-vector multiplication and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
    \item $\vector{\widetilde{t}}$: The vector holding the product of matrix 
    $\matrix{\widetilde{A}}$ and vector $\vector{\widetilde{u}}$.
    \item $\vector{\widetilde{z}}$: The vector holding the result after 
    application of the (optional) accumulation operator.
\end{itemize}

The intermediate vector $\vector{\widetilde{t}} = \langle
\bDout({\sf op}), \bold{nrows}(\matrix{\widetilde{A}}),
\{(i,t_i) : \bold{ind}(\matrix{\widetilde{A}}(i,:)) \cap 
\bold{ind}(\vector{\widetilde{u}}) \neq \emptyset \} \rangle$
is created.  The value of each of its elements is computed by 
\[t_i = \bigoplus_{k \in \bold{ind}(\matrix{\widetilde{A}}(i,:)) \cap
\bold{ind}(\vector{\widetilde{u}})} (\matrix{\widetilde{A}}(i,k)
\otimes \vector{\widetilde{u}}(k)),\] where $\oplus$ and $\otimes$
are the additive and multiplicative operators of semiring {\sf op},
respectively.

\input{ops_accum_z_vector}

\input{ops_mask_replace_vector}
