\subsection{{\sf scatter}: Scatter the elements of a vector or matrix}
\label{Sec:scatter}

Scatter the elements of a vector or matrix onto a (typically) larger
vector or matrix.

%-----------------------------------------------------------------------------
\subsubsection{{\sf scatter}: Standard vector variant}

Scatter all values of one GraphBLAS vector onto another,
typically larger,
vector as specified by a set of indices. The size of the input vector is the
same size as the index array provided.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_scatter(GrB_Vector              w,
                             const GrB_Vector        mask,
                             const GrB_BinaryOp      accum,
                             const GrB_Vector        u,
                             const GrB_Index        *indices,
                             const GrB_Index         nindices,
                             const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf w}]    ({\sf INOUT}) An existing GraphBLAS vector.  On input,
    the vector provides values that may be accumulated with the result of the
    scatter operation.  On output, this vector holds the results of the
    operation.

    \item[{\sf mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output vector {\sf w}. The 
    mask dimensions must match those of the vector {\sf w} and the domain of the
    {\sf mask} vector must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default vector
    is desired (\ie, with correct dimensions and filled with {\sf true}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]    ({\sf IN}) An optional operator used for accumulating
    entries into existing {\sf w} entries: ${\sf accum} = \langle D_x,
    D_y, D_z,\odot \rangle$. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf u}]        ({\sf IN}) The GraphBLAS vector whose contents are 
	   scattered onto {\sf w}.
    
    \item[{\sf indices}]  ({\sf IN}) Pointer to the ordered set (array) of 
    indices corresponding to the locations in {\sf w} that are the target of scatter.  
    If all elements of {\sf w} are to be targets in order from $0$ to 
    ${\sf nindices} - 1$, then {\sf GrB\_ALL} should be specified.  Regardless of 
    execution mode and return value, this array may be manipulated by the caller
    after this operation returns without affecting any deferred computations for 
    this operation.  
    If this array contains duplicate values, it implies an assignment of more 
    than one value to the same location which leads to undefined results.
    
    \item[{\sf nindices}] ({\sf IN}) The number of values in {\sf indices} array.
    Must be equal to $\bold{size}({\sf u})$.

    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \begin{tabular}{lllp{2.5in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w}
        is cleared (all elements removed) before the result is stored in it. \\
        
        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural 
        complement of {\sf mask}. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output vector {\sf w} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]            Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects
    has not been initialized by a call to {\sf new} (or {\sf dup} for vector
    parameters).

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}]  A value in {\sf indices} is greater
    than or equal to $\bold{size}({\sf w})$.  In non-blocking mode, this can be
    reported as an execution error.
    
    \item[{\sf GrB\_DIMENSION\_MISMATCH}] {\sf mask} and {\sf w} dimensions are
    incompatible, or ${\sf nindices} \neq \bold{size}({\sf u})$. 
    
    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various vectors are
	incompatible with each other or the corresponding domains of the
    accumulation operator, or the mask's domain is not compatible with {\sf bool}.

    \item[{\sf GrB\_NULL\_POINTER}] Argument {\sf indices} is a {\sf NULL} pointer.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_scatter} computes the result of scattering elements from 
a source GraphBLAS vector {\sf u} to a target GraphBLAS vector {\sf w}, which is defined by: 
\[
\begin{aligned}
	{\sf w}({\sf indices}[i]) = {\sf u}(i), \forall i : i \in \bold{ind}({\sf u}).
\end{aligned}
\]  

Optionally, the result from the scatter can be accumulated with the input value of {\sf w}
if a binary accumulation 
operator ($\odot$) is provided, 

Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[Setup] The internal vectors and mask used in the computation are formed 
and their domains and dimensions are tested for compatibility.
\item[Compute] The indicated computations are carried out.
\item[Output] The result is written into the output vector, possibly under 
control of a mask.
\end{enumerate}

Up to three argument vectors are used in the {\sf GrB\_scatter} operation:
\begin{enumerate}
	\item ${\sf w} = \langle \bold{D}({\sf w}),\bold{size}({\sf w}),
    \bold{L}({\sf w}) = \{(i,w_i) \} \rangle$
    
	\item ${\sf mask} = \langle \bold{D}({\sf mask}),\bold{size}({\sf mask}),
    \bold{L}({\sf mask}) = \{(i,m_i) \} \rangle$ (optional)
    
	\item ${\sf u} = \langle \bold{D}({\sf u}),\bold{size}({\sf u}),
    \bold{L}({\sf u}) = \{(i,u_i) \} \rangle$
\end{enumerate}

The argument vectors and the accumulation 
operator (if provided) are tested for domain compatibility as follows:
\begin{enumerate}
	\item The domain of {\sf mask} (if not {\sf GrB\_NULL}) must be from one of 
    the pre-defined types of Table~\ref{Tab:PredefinedTypes}.

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be 
    compatible with $\bold{D}({\sf u})$.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be
    compatible with $D_x$ and $D_z$ of the accumulation operator and 
    $\bold{D}({\sf u})$ must be compatible with $D_y$ of the accumulation operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_scatter} ends
and the domain mismatch error listed above is returned.

From the arguments, the internal vectors, mask and index array used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Vector $\vector{\widetilde{w}} \leftarrow {\sf w}$.

	\item One-dimensional mask, $\vector{\widetilde{m}}$, is computed from 
    argument {\sf mask} as follows:
	\begin{enumerate}
		\item	If ${\sf mask} = {\sf GrB\_NULL}$, then $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf w}), \{i, \forall i : 0 \leq i < 
        \bold{size}({\sf w}) \} \rangle$.

		\item	Otherwise, $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf mask}), \{i : i \in \bold{ind}({\sf mask}) \wedge
        ({\sf bool}){\sf mask}(i) = \true \} \rangle$.

		\item	If ${\sf desc[GrB\_MASK].GrB\_SCMP}$ is \true, then 
        $\vector{\widetilde{m}} \leftarrow \neg \vector{\widetilde{m}}$.
	\end{enumerate}

	\item Vector $\vector{\widetilde{u}} \leftarrow {\sf u}$.
    
    \item The internal index array, $\grbarray{\widetilde{I}}$, is computed from 
    argument {\sf indices} as follows:
	\begin{enumerate}
		\item	If ${\sf indices} = {\sf GrB\_ALL}$, then 
        $\grbarray{\widetilde{I}}[i] = i, \forall i : 0 \leq i < {\sf nindices}$.

		\item	Otherwise, $\grbarray{\widetilde{I}}[i] = {\sf indices}[i], 
        \forall i : 0 \leq i < {\sf nindices}$.
    \end{enumerate}
\end{enumerate}

The internal vectors and masks are checked for dimension compatibility. 
The following conditions must hold:
\begin{enumerate}
	\item $\bold{size}(\vector{\widetilde{w}}) = \bold{size}(\vector{\widetilde{m}})$
    \item ${\sf nindices} = \bold{size}(\vector{\widetilde{u}})$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_scatter} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can 
optionally exit with {\sf GrB\_SUCCESS} return code and defer any computation 
and/or execution error codes.

We are now ready to carry out the scatter and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
    \item $\vector{\widetilde{t}}$: The vector holding the elements from
    $\vector{\widetilde{u}}$ in their destination locations relative to 
    $\vector{\widetilde{w}}$.
    
    \item $\vector{\widetilde{z}}$: The vector holding the result after 
    application of the (optional) accumulation.
\end{itemize}

The intermediate vector, $\vector{\widetilde{t}}$, is created as follows:
\[
\vector{\widetilde{t}} = \langle
\bold{D}({\sf u}), \bold{size}(\vector{\widetilde{w}}),
%\bold{L}(\vector{\widetilde{t}}) =
\{(\grbarray{\widetilde{I}}[i],\vector{\widetilde{u}}(i)) \forall i, 0 \leq i < {\sf nindices} : 
i \in \bold{ind}(\vector{\widetilde{u}}) \} \rangle. 
\]
At this point, if any value of $\grbarray{\widetilde{I}}[i]$ is outside the valid 
range of indices for vector $\vector{\widetilde{w}}$, computation ends and the 
method returns the index-out-of-bounds error listed above. In 
{\sf GrB\_NONBLOCKING} mode, the error can be deferred until a 
sequence-terminating {\sf GrB\_wait()} is called.  Regardless, the result 
vector, {\sf w}, is invalid from this point forward in the 
sequence.

The intermediate vector $\vector{\widetilde{z}}$ is created as follows:
\begin{itemize}
    \item If ${\sf accum} = {\sf GrB\_NULL}$, then 
    $\vector{\widetilde{z}} = \vector{\widetilde{t}}$.

    \item If ${\sf accum} = \langle D_x, D_y, D_z, \odot \rangle$, then vector 
    $\vector{\widetilde{z}}$ is defined as 
        \[ 
        \vector{\widetilde{z}} =
        \langle D_z, \bold{size}(\vector{\widetilde{w}}), 
        %\bold{L}(\vector{\widetilde{z}}) =
		\{(i,z_{i})  \forall i \in \bold{ind}(\vector{\widetilde{w}}) \cup 
        \bold{ind}(\vector{\widetilde{t}}) \} \rangle.\]
    The values of the elements of $\vector{\widetilde{z}}$ are computed based 
    on the relationships between the sets of indices in $\vector{\widetilde{w}}$ 
    and $\vector{\widetilde{t}}$.
\[
    z_{i} = \vector{\widetilde{w}}(i) \odot \vector{\widetilde{t}}(i), \ \mbox{if}\  
    i \in  (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}})),
\]
\[
    z_{i} = \vector{\widetilde{w}}(i), \ \mbox{if}\  
    i \in  (\bold{ind}(\vector{\widetilde{w}}) - (\bold{ind}(\vector{\widetilde{t}})
    \cap \bold{ind}(\vector{\widetilde{w}}))),
\]
\[
    z_{i} = \vector{\widetilde{t}}(i), \ \mbox{if}\  i \in  
    (\bold{ind}(\vector{\widetilde{t}}) - (\bold{ind}(\vector{\widetilde{t}}) 
    \cap \bold{ind}(\vector{\widetilde{w}}))).
\]
where the difference operator in the previous expressions refers to set difference.
\end{itemize}

Finally, the set of output values that make up the $\vector{\widetilde{z}}$ 
vector are written into the final result vector, ${\sf w}$. 
This is carried out under control of the mask which acts as a ``write mask''.
\begin{itemize}
\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is set then any values in ${\sf w}$ 
on input to {\sf GrB\_scatter()} are deleted and the new output vector ${\sf w}$ is,
\[ \bold{L}({\sf w}) = \{(i,z_{i}) : i \in (\bold{ind}(\vector{\widetilde{z}}) 
\cap \bold{ind}(\vector{\widetilde{m}})) \}. \]

\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is not set, the elements of 
$\vector{\widetilde{z}}$ indicated by 
the mask are copied into the result vector, ${\sf w}$, and elements of 
${\sf w}$ that fall outside the set indicated by the mask are unchanged:
\[ \bold{L}({\sf w}) = \{(i,w_{i}) : i \in (\bold{ind}(\vector{\sf w}) 
\cap \bold{ind}(\neg \vector{\widetilde{m}})) \} \cup \{(i,z_{i}) : i \in 
(\bold{ind}(\vector{\widetilde{z}}) \cap \bold{ind}(\vector{\widetilde{m}})) \}. \]
\end{itemize}

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.

%-----------------------------------------------------------------------------

\subsubsection{{\sf scatter}: Standard matrix variant}

Scatter all values of one GraphBLAS matrix onto another,
typically larger, 
matrix as specified by a set of indices. The dimensions of the input matrix are
the same size as the row and column index arrays provided.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_scatter(GrB_Matrix              C,
                             const GrB_Matrix        Mask,
                             const GrB_BinaryOp      accum,
                             const GrB_Matrix        A,
                             const GrB_Index        *row_indices,
                             const GrB_Index         nrows,
                             const GrB_Index        *col_indices,
                             const GrB_Index         ncols,
                             const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf C}]    ({\sf INOUT}) An existing GraphBLAS Matrix.  On input,
    the matrix provides values that may be accumulated with the result of the
    scatter operation.  On output, this matrix holds the results of the
    operation.

    \item[{\sf Mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output matrix {\sf C}. The 
    mask dimensions must match those of the matrix {\sf C} and the domain of the 
    {\sf Mask} matrix must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    matrix is desired (\ie, with correct dimensions and filled with {\sf true}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]    ({\sf IN}) An optional operator used for accumulating
    entries into existing {\sf C} entries: ${\sf accum} = \langle D_x,
    D_y, D_z,\odot \rangle$. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf A}]       ({\sf IN}) The GraphBLAS matrix whose contents are 
    scattered onto {\sf C}.
    
    \item[{\sf row\_indices}]  ({\sf IN}) Pointer to the ordered set (array) of 
    indices corresponding to the rows of {\sf C} that are the target of scatter.  If all rows
    of {\sf C} are to be targets in order from $0$ to ${\sf nrows} - 1$, then 
    {\sf GrB\_ALL} can be specified.  Regardless of execution mode and return 
    value, this array may be manipulated by the caller after this operation 
    returns without affecting any deferred computations for this operation.
    If this array contains duplicate values, it implies assignment of more 
    than one value to the same location which leads to undefined results.

    \item[{\sf nrows}] ({\sf IN}) The number of values in {\sf row\_indices} 
	array. Must be equal to $\bold{nrows}({\sf A})$ if {\sf A} is not tranposed,
	or equal to $\bold{ncols}({\sf A})$ if {\sf A} is transposed.

    \item[{\sf col\_indices}]  ({\sf IN}) Pointer to the ordered set (array) of 
    indices corresponding to the columns of {\sf C} that are the target of scatter.  If all 
    columns of {\sf C} are to be targets in order from $0$ to ${\sf ncols} - 1$, 
    then {\sf GrB\_ALL} can be specified.  Regardless of execution mode and return 
    value, this array may be manipulated by the caller after this operation 
    returns without affecting any deferred computations for this operation.
    If this array contains duplicate values, it implies assignment of more 
    than one value to the same location which leads to undefined results.
    
    \item[{\sf ncols}] ({\sf IN}) The number of values in {\sf col\_indices} 
	array. Must be equal to $\bold{ncols}({\sf A})$ if {\sf A} is not tranposed,
	or equal to $\bold{nrows}({\sf A})$ if {\sf A} is transposed.

    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \begin{tabular}{lllp{2.5in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C}
        is cleared (all elements removed) before the result is stored in it. \\
        
        {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural 
        complement of {\sf Mask}. \\

        {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Apply transpose to 
        {\sf A} before scattering its elements.
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output matrix {\sf C} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects 
    has not been initialized by a call to {\sf new} (or {\sf dup} for matrix
    parameters).

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}]  A value in {\sf row\_indices} 
    is greater than or equal to $\bold{nrows}({\sf C})$, or a value in 
    {\sf col\_indices} is greater than or equal to $\bold{ncols}({\sf C})$.  In 
    non-blocking mode, this can be reported as an execution error.
    
    \item[{\sf GrB\_DIMENSION\_MISMATCH}] {\sf Mask} and {\sf C} dimensions are
    incompatible, ${\sf nrows} \neq \bold{nrows}({\sf A})$, or 
    ${\sf ncols} \neq \bold{ncols}({\sf A})$.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]     The domains of the various matrices
    are incompatible with each other or the corresponding domains of the 
    accumulation operator, or the mask's domain is not compatible with {\sf bool}.

    \item[{\sf GrB\_NULL\_POINTER}] Either argument {\sf row\_indices} is a {\sf NULL} pointer,
	    argument {\sf col\_indices} is a {\sf NULL} pointer, or both.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_scatter} computes the result of scattering elements 
of a source GraphBLAS matrix {\sf A} to a target GraphBLAS matrix {\sf C},
which is defined by:
\[
\begin{aligned}
  	{\sf C}({\sf row\_indices}[i],{\sf col\_indices}[j]) = &\ {\sf A}(i,j), 
	\ \forall \ i,j \ : (i,j) \in \bold{ind}({\sf A}),\ \mbox{or} \\
  	{\sf C}({\sf row\_indices}[i],{\sf col\_indices}[j]) = &\ {\sf A}(j,i), 
	\ \forall \ i,j \ : (j,i) \in \bold{ind}({\sf A})\ \mbox{if {\sf A} is transposed}. \\
\end{aligned}
\]  
Optionally, the result from the scatter can be accumulated
with the input value of {\sf C} if a
binary accumulation operator ($\odot$) is provided, 

Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[Setup] The internal matrices and mask used in the computation are formed 
and their domains and dimensions are tested for compatibility.
\item[Compute] The indicated computations are carried out.
\item[Output] The result is written into the output matrix, possibly under 
control of a mask.
\end{enumerate}

Up to three argument matrices are used in the {\sf GrB\_scatter} operation:
\begin{enumerate}
	\item ${\sf C} = \langle \bold{D}({\sf C}),\bold{nrows}({\sf C}),
    \bold{ncols}({\sf C}),\bold{L}({\sf C}) = \{(i,j,C_{ij}) \} \rangle$
    
	\item ${\sf Mask} = \langle \bold{D}({\sf Mask}),\bold{nrows}({\sf Mask}),
    \bold{ncols}({\sf Mask}),\bold{L}({\sf Mask}) = \{(i,j,M_{ij}) \} \rangle$ (optional)
    
	\item ${\sf A} = \langle \bold{D}({\sf A}),\bold{nrows}({\sf A}), 
    \bold{ncols}({\sf A}),\bold{L}({\sf A}) = \{(i,j,A_{ij}) \} \rangle$
\end{enumerate}

The argument matrices and the accumulation 
operator (if provided) are tested for domain compatibility as follows:
\begin{enumerate}
	\item The domain of {\sf Mask} (if not {\sf GrB\_NULL}) must be from one of 
    the pre-defined types of Table~\ref{Tab:PredefinedTypes}.

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be 
    compatible with $\bold{D}({\sf A})$.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be
    compatible with $D_x$ and $D_z$ of the accumulation operator and 
    $\bold{D}({\sf A})$ must be compatible with $D_y$ of the accumulation operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_scatter} ends
and the domain mismatch error listed above is returned.

From the arguments, the internal matrices, index arrays, and mask used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Matrix $\matrix{\widetilde{C}} \leftarrow {\sf C}$.

	\item Two-dimensional mask $\matrix{\widetilde{M}}$ is computed from 
    argument {\sf Mask} as follows:
	\begin{enumerate}

		\item	If ${\sf Mask} = {\sf GrB\_NULL}$, then $\matrix{\widetilde{M}} = 
        \langle \bold{nrows}({\sf C}), \bold{ncols}({\sf C}), \{(i,j), 
        \forall i,j : 0 \leq i <  \bold{nrows}({\sf C}), 0 \leq j < 
        \bold{ncols}({\sf C}) \} \rangle$.

		\item	Otherwise, $\matrix{\widetilde{M}} = \langle 
        \bold{nrows}({\sf Mask}), \bold{ncols}({\sf Mask}), \{(i,j) : 
        (i,j) \in \bold{ind}({\sf Mask}) \wedge 
        ({\sf bool}){\sf Mask}(i,j) = \true\} \rangle$.

		\item	If ${\sf desc[GrB\_MASK].GrB\_SCMP}$ is set, then 
        $\matrix{\widetilde{M}} \leftarrow \neg \matrix{\widetilde{M}}$.
	\end{enumerate}

	\item Matrix $\matrix{\widetilde{A}} \leftarrow 
    {\sf desc[GrB\_INP0].GrB\_TRAN} \ ? \ {\sf A}^T : {\sf A}$.

    \item The internal row index array, $\grbarray{\widetilde{I}}$, is computed from 
    argument {\sf row\_indices} as follows:
	\begin{enumerate}
		\item	If ${\sf row\_indices} = {\sf GrB\_ALL}$, then 
        $\grbarray{\widetilde{I}}[i] = i, \forall i : 0 \leq i < {\sf nrows}$.

		\item	Otherwise, $\grbarray{\widetilde{I}}[i] = {\sf row\_indices}[i], 
        \forall i : 0 \leq i < {\sf nrows}$.
    \end{enumerate}
    
    \item The internal column index array, $\grbarray{\widetilde{J}}$, is computed from 
    argument {\sf col\_indices} as follows:
	\begin{enumerate}
		\item	If ${\sf col\_indices} = {\sf GrB\_ALL}$, then 
        $\grbarray{\widetilde{J}}[j] = j, \forall j : 0 \leq j < {\sf ncols}$.

		\item	Otherwise, $\grbarray{\widetilde{J}}[j] = {\sf col\_indices}[j], 
        \forall j : 0 \leq j < {\sf ncols}$.
    \end{enumerate}
\end{enumerate}

The internal matrices and mask are checked for shape compatibility. The following 
conditions must hold:
\begin{enumerate}
    \item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{M}})$.

    \item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{M}})$.

    \item $\bold{nrows}(\matrix{\widetilde{A}}) = {\sf nrows}$.

    \item $\bold{ncols}(\matrix{\widetilde{A}}) = {\sf ncols}$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_scatter} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can 
optionally exit with {\sf GrB\_SUCCESS} return code and defer any computation 
and/or execution error codes.

We are now ready to carry out the scatter and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
	\item $\matrix{\widetilde{T}}$: The matrix holding the contents from
    $\matrix{\widetilde{A}}$ in their destination locations relative to
    $\matrix{\widetilde{C}}$.

	\item $\matrix{\widetilde{Z}}$: The matrix holding the result after 
    application of the (optional) accumulation operator.
\end{itemize}

The intermediate matrix, $\matrix{\widetilde{T}}$, is created as follows:
\[ 
\begin{aligned}
\matrix{\widetilde{T}} = \langle & \bold{D}({\sf A}), 
                           \bold{nrows}(\matrix{\widetilde{C}}), 
                           \bold{ncols}(\matrix{\widetilde{C}}), \\
 & \{ (\grbarray{\widetilde{I}}[i],\grbarray{\widetilde{J}}[j],\matrix{\widetilde{A}}(i,j)) 
\ \forall \ (i,j), \ 0 \leq i < {\sf nrows}, \ 0 \leq j < {\sf ncols} :
(i,j) \in \bold{ind}(\matrix{\widetilde{A}}) \} \rangle. 
\end{aligned}
\]
At this point, if any value in the $\grbarray{\widetilde{I}}$ array is not in
the range $[0,\ \bold{nrows}(\matrix{\widetilde{C}}) )$ or any value in the 
$\grbarray{\widetilde{J}}$ array is not in the range 
$[0,\ \bold{ncols}(\matrix{\widetilde{C}}))$, the execution of {\sf GrB\_scatter} 
ends and the index out-of-bounds error listed above is generated.  In 
{\sf GrB\_NONBLOCKING} mode, the error can be deferred until a 
sequence-terminating {\sf GrB\_wait()} is called.  Regardless, the result 
matrix {\sf C} is invalid from this point forward in the sequence.

The intermediate matrix $\matrix{\widetilde{Z}}$ is created as follows:
\begin{itemize}
    \item If ${\sf accum} = {\sf GrB\_NULL}$, then 
    $\matrix{\widetilde{Z}} = \matrix{\widetilde{T}}$.

    \item If ${\sf accum} = \langle D_x, D_y, D_z, \odot \rangle$, then matrix 
    $\matrix{\widetilde{Z}}$ is defined as 
        \[ 
        \matrix{\widetilde{Z}} =
        \langle D_z, \bold{nrows}(\matrix{\widetilde{C}}),
        \bold{ncols}(\matrix{\widetilde{C}}), 
        %\bold{L}(\matrix{\widetilde{Z}}) =
		\{(i,j,Z_{ij})  \forall (i,j) \in \bold{ind}(\matrix{\widetilde{C}}) \cup 
        \bold{ind}(\matrix{\widetilde{T}}) \} \rangle.\]
    The values of the elements of $\matrix{\widetilde{Z}}$ are computed based on 
    the relationships between the sets of indices in $\matrix{\widetilde{C}}$ and 
    $\matrix{\widetilde{T}}$.
\[
	Z_{ij} = \matrix{\widetilde{C}}(i,j) \odot \matrix{\widetilde{T}}(i,j), 
    \mbox{~if~} (i,j) \in  (\bold{ind}(\matrix{\widetilde{T}}) \cap 
    \bold{ind}(\matrix{\widetilde{C}})),
\]
\[
	Z_{ij} = \matrix{\widetilde{C}}(i,j), \mbox{~if~}  (i,j) \in  
    (\bold{ind}(\matrix{\widetilde{C}}) - (\bold{ind}(\matrix{\widetilde{T}}) \cap 
    \bold{ind}(\matrix{\widetilde{C}}))),
\]
\[
	Z_{ij} = \matrix{\widetilde{T}}(i,j), \mbox{~if~}  (i,j) \in  
    (\bold{ind}(\matrix{\widetilde{T}}) - (\bold{ind}(\matrix{\widetilde{T}}) \cap 
    \bold{ind}(\matrix{\widetilde{C}}))).
\]
where the difference operator in the previous expressions refers to set difference.
\end{itemize}

Finally, the set of output values that make up the $\matrix{\widetilde{Z}}$ 
matrix are written into the final result matrix, ${\sf C}$. 
This is carried out under control of the mask which acts as a ``write mask''.
\begin{itemize}
\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is set then any values in ${\sf C}$ 
on input to {\sf GrB\_scatter()} are deleted and the new output matrix ${\sf C}$ is,
		\[ \bold{L}({\sf C}) = \{(i,j,Z_{ij}) : (i,j) \in (\bold{ind}(\matrix{\widetilde{Z}}) 
\cap \bold{ind}(\matrix{\widetilde{M}})) \}. \]

\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is not set, the elements of 
$\matrix{\widetilde{Z}}$ indicated by 
the mask are copied into the result matrix, ${\sf C}$, and elements of 
${\sf C}$ that fall outside the set indicated by the mask are unchanged:
		\[ \bold{L}({\sf C}) = \{(i,j,C_{ij}) : (i,j) \in (\bold{ind}(\matrix{\sf C}) 
		\cap \bold{ind}(\neg \matrix{\widetilde{M}})) \} \cup \{(i,j,Z_{ij}) : (i,j) \in 
(\bold{ind}(\matrix{\widetilde{Z}}) \cap \bold{ind}(\matrix{\widetilde{M}})) \}. \]
\end{itemize}

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of matrix {\sf C} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of matrix {\sf C} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.

%-----------------------------------------------------------------------------
\subsubsection{{\sf scatter}: Column variant}

Assign the contents a vector to a subset of elements in one column of a matrix. 
Note that since the output cannot be transposed, a different variant of
{\sf scatter} is provided to scatter to a row of a matrix.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_scatter(GrB_Matrix              C,
                            const GrB_Vector        mask,
                            const GrB_BinaryOp      accum,
                            const GrB_Vector        u,
                            const GrB_Index        *row_indices,
                            const GrB_Index         nrows,
                            GrB_Index               col_index,
                            const GrB_Descriptor    desc); 
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    ({\sf INOUT}) An existing GraphBLAS Matrix.  On input,
    the matrix provides values that may be accumulated with the result of the
    assign operation.  On output, this matrix holds the results of the
    operation.

    \item[{\sf mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the specified column of the output matrix {\sf C}. The 
    mask dimensions must match those of a single column of the matrix {\sf C} and the domain of the 
    {\sf Mask} matrix must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    vector is desired (\ie, with correct dimensions and filled with {\sf true}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]    ({\sf IN}) An optional operator used for accumulating
    entries into existing {\sf C} entries: ${\sf accum} = \langle D_x,
    D_y, D_z,\odot \rangle$. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf u}]       ({\sf IN}) The GraphBLAS vector whose contents are 
    assigned to (a subset of) a column of {\sf C}.

    \item[{\sf row\_indices}]  ({\sf IN}) Pointer to the ordered set (array) of 
    indices corresponding to the locations in the specified column of {\sf C} 
    that are to be assigned.  If all elements of the column in {\sf C} are to be 
    assigned in order from index $0$ to ${\sf nrows} - 1$, then {\sf GrB\_ALL} should be 
    specified.  Regardless of execution mode and return value, this array may be
    manipulated by the caller after this operation returns without affecting any 
    deferred computations for this operation.
    If this array contains duplicate values, it implies in assignment of more 
    than one value to the same location which leads to undefined results.
    
    \item[{\sf nrows}] ({\sf IN}) The number of values in {\sf row\_indices} array.
    Must be equal to $\bold{size}({\sf u})$.
    
    \item[{\sf col\_index}]  ({\sf IN}) The index of the column in {\sf C} to 
    assign. Must be in the range $[0, \bold{ncols}({\sf C}))$.

    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \begin{tabular}{lllp{2.5in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} &  Output column in 
        {\sf C} is cleared (all elements removed) before result is stored in it.\\
    
        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural 
        complement of {\sf mask}. \\
    \end{tabular}

\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output matrix {\sf C} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]            Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects
    has not been initialized by a call to {\sf new} (or {\sf dup} for vector or
    matrix parameters).

    \item[{\sf GrB\_INVALID\_INDEX}]    {\sf col\_index} is outside the allowable 
    range (i.e., greater than $\bold{ncols}({\sf C})$).

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}]  A value in {\sf row\_indices} 
    is greater than or equal to $\bold{nrows}({\sf C})$.  In 
    non-blocking mode, this can be reported as an execution error.
    
    \item[{\sf GrB\_DIMENSION\_MISMATCH}] {\sf mask} size and number of rows
    in {\sf C} are not the same, or ${\sf nrows} \neq \bold{size}({\sf u})$.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]     The domains of the matrix and vector
    are incompatible with each other or the corresponding domains of the 
    accumulation operator, or the mask's domain is not compatible with {\sf bool}.

    \item[{\sf GrB\_NULL\_POINTER}] Argument {\sf row\_indices} is a {\sf NULL} pointer.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_assign} computes the result of assigning a subset of
locations in a column of a GraphBLAS matrix (in a specific order) from the 
contents of a GraphBLAS vector: \\
${\sf C}(:,{\sf col\_index}) = {\sf u}$; or, if an 
optional binary accumulation operator ($\odot$) is provided, 
${\sf C}(:,{\sf col\_index}) = 
{\sf C}(:,{\sf col\_index}) \odot {\sf u}$. Taking order of {\sf row\_indices} 
into account, it is more explicitly written as:
\[
\begin{aligned}
    {\sf C}({\sf row\_indices}[i],{\sf col\_index}) = &\ {\sf u}(i) 
    \ \forall \ i \ : \ 0 \leq i < {\sf nrows}, \mbox{~or~}
    \\
    {\sf C}({\sf row\_indices}[i],{\sf col\_index}) = &\ 
    {\sf C}({\sf row\_indices}[i],{\sf col\_index}) \odot {\sf u}(i) 
    \ \forall \ i \ : \ 0 \leq i < {\sf nrows}
\end{aligned}
\]  
Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[\bf Setup] The internal matrices, vectors and mask used in the computation are formed 
and their domains and dimensions are tested for compatibility.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output matrix, possibly under 
control of a mask.
\end{enumerate}

Up to three argument vectors and matrices are used in this {\sf GrB\_assign} 
operation:
\begin{enumerate}
	\item ${\sf C} = \langle \bold{D}({\sf C}),\bold{nrows}({\sf C}),
    \bold{ncols}({\sf C}),\bold{L}({\sf C}) = \{(i,j,C_{ij}) \} \rangle$
    
	\item ${\sf mask} = \langle \bold{D}({\sf mask}),\bold{size}({\sf mask}),
    \bold{L}({\sf mask}) = \{(i,m_{i}) \} \rangle$ (optional)

	\item ${\sf u} = \langle \bold{D}({\sf u}),\bold{size}({\sf u}),
    \bold{L}({\sf u}) = \{(i,u_i) \} \rangle$
\end{enumerate}

The argument vectors, matrix, and the accumulation 
operator (if provided) are tested for domain compatibility as follows:
\begin{enumerate}
	\item The domain of {\sf mask} (if not {\sf GrB\_NULL}) must be from one of 
    the pre-defined types of Table~\ref{Tab:PredefinedTypes}.

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be 
    compatible with $\bold{D}({\sf u})$.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be
    compatible with $D_x$ and $D_z$ of the accumulation operator and 
    $\bold{D}({\sf u})$ must be compatible with $D_y$ of the accumulation operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_assign} ends
and the domain mismatch error listed above is returned.

The {\sf col\_index} parameter is checked for a valid value.  The following
condition must hold:
\begin{enumerate}
	\item $0\ \leq\ {\sf col\_index} \ <\ \bold{ncols}({\sf C})$
\end{enumerate}
If the rule above is violated, execution of {\sf GrB\_assign} ends 
and the invalid index error listed above is returned.

From the arguments, the internal vectors, mask, and index array used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item The vector, $\vector{\widetilde{c}}$, is extracted from a column of {\sf C}
    as follows:
    \[
        \vector{\widetilde{c}} = \langle  \bold{D}({\sf C}), \bold{nrows}({\sf C}), 
        \{ (i, C_{ij}) \ \forall \ i : 0 \leq i < \bold{nrows}({\sf C}),
        j = {\sf col\_index}, (i, j) \in \bold{ind}({\sf C})\} \rangle
    \]

	\item One-dimensional mask, $\vector{\widetilde{m}}$, is computed from 
    argument {\sf mask} as follows:
	\begin{enumerate}
		\item	If ${\sf mask} = {\sf GrB\_NULL}$, then $\vector{\widetilde{m}} = 
        \langle \bold{nrows}({\sf C}), \{i,\ \forall \ i : 0 \leq i < 
        \bold{nrows}({\sf C}) \} \rangle$.

		\item	Otherwise, $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf mask}), \{i : i \in \bold{ind}({\sf mask}) \wedge
        ({\sf bool}){\sf mask}(i) = \true \} \rangle$.

		\item	If ${\sf desc[GrB\_MASK].GrB\_SCMP}$ is \true, then 
        $\vector{\widetilde{m}} \leftarrow \neg \vector{\widetilde{m}}$.
	\end{enumerate}

	\item Vector $\vector{\widetilde{u}} \leftarrow {\sf u}$.
    
    \item The internal row index array, $\grbarray{\widetilde{I}}$, is computed from 
    argument {\sf row\_indices} as follows:
	\begin{enumerate}
		\item	If ${\sf row\_indices} = {\sf GrB\_ALL}$, then 
        $\grbarray{\widetilde{I}}[i] = i, \ \forall \ i : 0 \leq i < {\sf nrows}$.

		\item	Otherwise, $\grbarray{\widetilde{I}}[i] = {\sf row\_indices}[i], 
        \forall i : 0 \leq i < {\sf nrows}$.
    \end{enumerate}
\end{enumerate}

The internal vectors, matrices, and masks are checked for dimension compatibility. 
The following conditions must hold:
\begin{enumerate}
	\item $\bold{size}(\vector{\widetilde{c}}) = \bold{size}(\vector{\widetilde{m}})$
    \item ${\sf nrows} = \bold{size}(\vector{\widetilde{u}})$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_assign} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can 
optionally exit with {\sf GrB\_SUCCESS} return code and defer any computation 
and/or execution error codes.

We are now ready to carry out the assign and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
    \item $\vector{\widetilde{t}}$: The vector holding the elements from
    $\vector{\widetilde{u}}$ in their destination locations relative to 
    $\vector{\widetilde{c}}$.
    
    \item $\vector{\widetilde{z}}$: The vector holding the result after 
    application of the (optional) accumulation.
\end{itemize}

The intermediate vector, $\vector{\widetilde{t}}$, is created as follows:
\[
\vector{\widetilde{t}} = \langle
\bold{D}({\sf u}), \bold{size}(\vector{\widetilde{c}}),
%\bold{L}(\vector{\widetilde{t}}) =
\{(\grbarray{\widetilde{I}}[i],\vector{\widetilde{u}}(i))\ \forall \ i,
 0 \leq i < {\sf nrows} : i \in \bold{ind}(\vector{\widetilde{u}}) \} \rangle. 
\]
At this point, if any value of $\grbarray{\widetilde{I}}[i]$ is outside the valid 
range of indices for vector $\vector{\widetilde{c}}$, computation ends and the 
method returns the index out-of-bounds error listed above. In 
{\sf GrB\_NONBLOCKING} mode, the error can be deferred until a 
sequence-terminating {\sf GrB\_wait()} is called.  Regardless, the result 
matrix, {\sf C}, is invalid from this point forward in the 
sequence.

The intermediate vector $\vector{\widetilde{z}}$ is created as follows:
\begin{itemize}
    \item If ${\sf accum} = {\sf GrB\_NULL}$, then 
    $\vector{\widetilde{z}} = \vector{\widetilde{t}}$.

    \item If ${\sf accum} = \langle D_x, D_y, D_z, \odot \rangle$, then vector 
    $\vector{\widetilde{z}}$ is defined as 
        \[ 
        \vector{\widetilde{z}} = 
        \langle D_z, \bold{size}(\vector{\widetilde{c}}), 
        %\bold{L}(\vector{\widetilde{z}}) = 
        \{(i,z_{i}),   
        \ \forall \ i \in \bold{ind}(\vector{\widetilde{c}}) \cup 
        \bold{ind}(\vector{\widetilde{t}}) \} \rangle.\]
    The values of the elements of $\vector{\widetilde{z}}$ are computed based on the relationships between the sets of indices in $\vector{\widetilde{w}}$ and $\vector{\widetilde{t}}$.
\[
z_{i} = \vector{\widetilde{c}}(i) \odot \vector{\widetilde{t}}(i), \ \mbox{if}\  
i \in  (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{c}})),
\]
\[
z_{i} = \vector{\widetilde{c}}(i), \ \mbox{if}\  i \in  (\bold{ind}(
\vector{\widetilde{c}}) - (\bold{ind}(\vector{\widetilde{t}}) \cap 
\bold{ind}(\vector{\widetilde{c}}))),
\]
\[
z_{i} = \vector{\widetilde{t}}(i), \ \mbox{if}\  i \in  (\bold{ind}(
\vector{\widetilde{t}}) - (\bold{ind}(\vector{\widetilde{t}}) \cap 
\bold{ind}(\vector{\widetilde{c}}))).
\]
where the difference operator in the previous expressions refers to set difference.
\end{itemize}

Finally, the set of output values that make up the $\vector{\widetilde{z}}$ 
vector are written into the column of the final result matrix, 
${\sf C}(:,{\sf col\_index})$.  This is carried out under control of the mask 
which acts as a ``write mask''.
\begin{itemize}
    \item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is set then any values in 
    ${\sf C}(:,{\sf col\_index})$ on input to {\sf GrB\_assign()} are deleted 
    and the new content of the column is given by:
    \[ 
		\bold{L}({\sf C}) = \{ (i,j,C_{ij}) : j \neq {\sf col\_index} \} \cup \{(i,{\sf col\_index},z_{i}) : i \in 
    (\bold{ind}(\vector{\widetilde{z}}) \cap \bold{ind}(\vector{\widetilde{m}})) \}. 
    \]

    \item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is not set, the elements of 
    $\vector{\widetilde{z}}$ indicated by the mask are copied into the column 
    of the final result matrix, ${\sf C}(:,{\sf col\_index})$, and elements of 
    this column that fall outside the set indicated by the mask are unchanged:
		\begin{eqnarray} 
			\bold{L}({\sf C}) & = & \{ (i,j,C_{ij}) : j \neq {\sf col\_index} \} \cup \nonumber \\
			& & \{(i,{\sf col\_index},\vector{\widetilde{c}}(i)) : i \in (\bold{ind}(\vector{\widetilde{c}}) 
		\cap \bold{ind}(\neg \vector{\widetilde{m}})) \} \cup \nonumber \\
			& & \{(i,{\sf col\_index},z_{i}) : i \in 
    (\bold{ind}(\vector{\widetilde{z}}) \cap \bold{ind}(\vector{\widetilde{m}})) \}. \nonumber
		\end{eqnarray}
\end{itemize}

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.


%-----------------------------------------------------------------------------
\subsubsection{{\sf scatter}: Row variant}

Assign the contents a vector to a subset of elements in one row of a matrix. 
Note that since the output cannot be transposed, a different variant of
{\sf scatter} is provided to scatter to a column of a matrix.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_scatter(GrB_Matrix              C,
                            const GrB_Vector        mask,
                            const GrB_BinaryOp      accum,
                            const GrB_Vector        u,
                            GrB_Index               row_index,
                            const GrB_Index        *col_indices,
                            const GrB_Index         ncols,
                            const GrB_Descriptor    desc); 
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    ({\sf INOUT}) An existing GraphBLAS Matrix.  On input,
    the matrix provides values that may be accumulated with the result of the
    assign operation.  On output, this matrix holds the results of the
    operation.

    \item[{\sf mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the specified row of the output matrix {\sf C}. The 
    mask dimensions must match those of a single row of the matrix {\sf C} and the domain of the 
    {\sf Mask} matrix must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    vector is desired (\ie, with correct dimensions and filled with {\sf true}), 
    {\sf GrB\_NULL} should be specified.
    
    \item[{\sf accum}]    ({\sf IN}) An optional operator used for accumulating
    entries into existing {\sf C} entries: ${\sf accum} = \langle D_x,
    D_y, D_z,\odot \rangle$. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf u}]       ({\sf IN}) The GraphBLAS vector whose contents are 
    assigned to (a subset of) a row of {\sf C}.

    \item[{\sf row\_index}]  ({\sf IN}) The index of the row in {\sf C} to 
    assign. Must be in the range $[0, \bold{nrows}({\sf C}))$.

    \item[{\sf col\_indices}]  ({\sf IN}) Pointer to the ordered set (array) of 
    indices corresponding to the locations in the specified row of {\sf C} 
    that are to be assigned.  If all elements of the row in {\sf C} are to be 
    assigned in order from index $0$ to ${\sf ncols} - 1$, then {\sf GrB\_ALL} should be 
    specified.  Regardless of execution mode and return value, this array may be
    manipulated by the caller after this operation returns without affecting any 
    deferred computations for this operation.
    If this array contains duplicate values, it implies in assignment of more 
    than one value to the same location which leads to undefined results.
    
    \item[{\sf ncols}] ({\sf IN}) The number of values in {\sf col\_indices} array.
    Must be equal to $\bold{size}({\sf u})$.

    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \begin{tabular}{lllp{2.5in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} &   Output row in 
        {\sf C} is cleared (all elements removed) before result is stored in it. \\
        
        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP} & Use the structural 
        complement of {\sf mask}. \\
    \end{tabular}

\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output matrix {\sf C} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]            Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects
    has not been initialized by a call to {\sf new} (or {\sf dup} for vector or
    matrix parameters).

    \item[{\sf GrB\_INVALID\_INDEX}]    {\sf row\_index} is outside the allowable 
    range (i.e., greater than $\bold{nrows}({\sf C})$).

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}]  A value in {\sf col\_indices} 
    is greater than or equal to $\bold{ncols}({\sf C})$.  In 
    non-blocking mode, this can be reported as an execution error.

    \item[{\sf GrB\_DIMENSION\_MISMATCH}] {\sf mask} size and number of columns
    in {\sf C} are not the same, or ${\sf ncols} \neq \bold{size}({\sf u})$.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]     The domains of the matrix and vector
    are incompatible with each other or the corresponding domains of the 
    accumulation operator, or the mask's domain is not compatible with {\sf bool}.

    \item[{\sf GrB\_NULL\_POINTER}] Argument {\sf col\_indices} is a {\sf NULL} pointer.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_assign} computes the result of assigning a subset of
locations in a row of a GraphBLAS matrix (in a specific order) from the 
contents of a GraphBLAS vector: 
${\sf C}({\sf row\_index},:) = {\sf u}$; or, if an 
optional binary accumulation operator ($\odot$) is provided, 
${\sf C}({\sf row\_index},:) = 
{\sf C}({\sf row\_index},:) \odot {\sf u}$. Taking order into account it is
more explicitly written as:
\[
\begin{aligned}
    {\sf C}({\sf row\_index},{\sf col\_indices}[j]) = &\ {\sf u}(j),
    \ \forall \ j \ : \ 0 \leq j < {\sf ncols}, \mbox{~or~}
    \\
    {\sf C}({\sf row\_index},{\sf col\_indices}[j]) = &\ {\sf C}({\sf row\_index},{\sf col\_indices}[j]) \odot {\sf u}(j), 
    \ \forall \ j \ : \ 0 \leq j < {\sf ncols}
\end{aligned}
\]  
Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[\bf Setup] The internal matrices, vectors and mask used in the computation are formed 
and their domains and dimensions are tested for compatibility.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output matrix, possibly under 
control of a mask.
\end{enumerate}

Up to three argument vectors and matrices are used in this {\sf GrB\_assign} 
operation:
\begin{enumerate}
	\item ${\sf C} = \langle \bold{D}({\sf C}),\bold{nrows}({\sf C}),
    \bold{ncols}({\sf C}),\bold{L}({\sf C}) = \{(i,j,C_{ij}) \} \rangle$
    
	\item ${\sf mask} = \langle \bold{D}({\sf mask}),\bold{size}({\sf mask}),
    \bold{L}({\sf mask}) = \{(i,m_{i}) \} \rangle$ (optional)

	\item ${\sf u} = \langle \bold{D}({\sf u}),\bold{size}({\sf u}),
    \bold{L}({\sf u}) = \{(i,u_i) \} \rangle$
\end{enumerate}

The argument vectors, matrix, and the accumulation 
operator (if provided) are tested for domain compatibility as follows:
\begin{enumerate}
	\item The domain of {\sf mask} (if not {\sf GrB\_NULL}) must be from one of 
    the pre-defined types of Table~\ref{Tab:PredefinedTypes}.

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be 
    compatible with $\bold{D}({\sf u})$.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be
    compatible with $D_x$ and $D_z$ of the accumulation operator and 
    $\bold{D}({\sf u})$ must be compatible with $D_y$ of the accumulation operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_assign} ends
and the domain mismatch error listed above is returned.

The {\sf row\_index} parameter is checked for a valid value.  The following
condition must hold:
\begin{enumerate}
	\item $0\ \leq\ {\sf row\_index} \ <\ \bold{nrows}({\sf C})$
\end{enumerate}
If the rule above is violated, execution of {\sf GrB\_assign} ends 
and the invalid index error listed above is returned.

From the arguments, the internal vectors, mask, and index array used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item The vector, $\vector{\widetilde{c}}$, is extracted from a row of {\sf C}
    as follows:
    \[
        \vector{\widetilde{c}} = \langle  \bold{D}({\sf C}), \bold{ncols}({\sf C}), 
        \{ (j, C_{ij}) \ \forall \ j : 0 \leq j < \bold{ncols}({\sf C}),
        i = {\sf row\_index}, (i, j) \in \bold{ind}({\sf C})\} \rangle
    \]

	\item One-dimensional mask, $\vector{\widetilde{m}}$, is computed from 
    argument {\sf mask} as follows:
	\begin{enumerate}
		\item	If ${\sf mask} = {\sf GrB\_NULL}$, then $\vector{\widetilde{m}} = 
        \langle \bold{ncols}({\sf C}), \{i, \forall i : 0 \leq i < 
        \bold{ncols}({\sf C}) \} \rangle$.

		\item	Otherwise, $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf mask}), \{i : i \in \bold{ind}({\sf mask}) \wedge
        ({\sf bool}){\sf mask}(i) = \true \} \rangle$.

		\item	If ${\sf desc[GrB\_MASK].GrB\_SCMP}$ is \true, then 
        $\vector{\widetilde{m}} \leftarrow \neg \vector{\widetilde{m}}$.
	\end{enumerate}

	\item Vector $\vector{\widetilde{u}} \leftarrow {\sf u}$.
    
    \item The internal column index array, $\grbarray{\widetilde{J}}$, is computed from 
    argument {\sf col\_indices} as follows:
	\begin{enumerate}
		\item	If ${\sf col\_indices} = {\sf GrB\_ALL}$, then 
        $\grbarray{\widetilde{J}}[j] = j, \forall j : 0 \leq j < {\sf ncols}$.

		\item	Otherwise, $\grbarray{\widetilde{J}}[j] = {\sf col\_indices}[j], 
        \forall j : 0 \leq j < {\sf ncols}$.
    \end{enumerate}
\end{enumerate}

The internal vectors, matrices, and masks are checked for dimension compatibility. 
The following conditions must hold:
\begin{enumerate}
	\item $\bold{size}(\vector{\widetilde{c}}) = \bold{size}(\vector{\widetilde{m}})$
    \item ${\sf ncols} = \bold{size}(\vector{\widetilde{u}})$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_assign} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can 
optionally exit with {\sf GrB\_SUCCESS} return code and defer any computation 
and/or execution error codes.

We are now ready to carry out the assign and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
    \item $\vector{\widetilde{t}}$: The vector holding the elements from
    $\vector{\widetilde{u}}$ in their destination locations relative to 
    $\vector{\widetilde{c}}$.
    
    \item $\vector{\widetilde{z}}$: The vector holding the result after 
    application of the (optional) accumulation.
\end{itemize}

The intermediate vector, $\vector{\widetilde{t}}$, is created as follows:
\[
\vector{\widetilde{t}} = \langle
\bold{D}({\sf u}), \bold{size}(\vector{\widetilde{c}}),
%\bold{L}(\vector{\widetilde{t}}) =
\{(\grbarray{\widetilde{J}}[j],\vector{\widetilde{u}}(j)) \ \forall \ j, \ 
0 \leq j < {\sf ncols} : j \in \bold{ind}(\vector{\widetilde{u}}) \} \rangle. 
\]
At this point, if any value of $\grbarray{\widetilde{J}}[j]$ is outside the valid 
range of indices for vector $\vector{\widetilde{c}}$, computation ends and the 
method returns the index out-of-bounds error listed above. In 
{\sf GrB\_NONBLOCKING} mode, the error can be deferred until a 
sequence-terminating {\sf GrB\_wait()} is called.  Regardless, the result 
matrix, {\sf C}, is invalid from this point forward in the 
sequence.

The intermediate vector $\vector{\widetilde{z}}$ is created as follows:
\begin{itemize}
    \item If ${\sf accum} = {\sf GrB\_NULL}$, then 
    $\vector{\widetilde{z}} = \vector{\widetilde{t}}$.

    \item If ${\sf accum} = \langle D_x, D_y, D_z, \odot \rangle$, then vector 
    $\vector{\widetilde{z}}$ is defined as 
        \[ 
        \vector{\widetilde{z}} =
        \langle D_z, \bold{size}(\vector{\widetilde{c}}), 
        %\bold{L}(\vector{\widetilde{z}}) = 
        \{(j,z_{j}) \ \forall \ j \in \bold{ind}(\vector{\widetilde{c}}) \cup 
        \bold{ind}(\vector{\widetilde{t}}) \} \rangle.
        \]
    The values of the elements of $\vector{\widetilde{z}}$ are computed based on the relationships between the sets of indices in $\vector{\widetilde{w}}$ and $\vector{\widetilde{t}}$.
\[
z_{j} = \vector{\widetilde{c}}(j) \odot \vector{\widetilde{t}}(j), \ \mbox{if}\  
j \in  (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{c}})),
\]
\[
z_{j} = \vector{\widetilde{c}}(j), \ \mbox{if}\  j \in  (\bold{ind}(
\vector{\widetilde{c}}) - (\bold{ind}(\vector{\widetilde{t}}) \cap 
\bold{ind}(\vector{\widetilde{c}}))),
\]
\[
z_{j} = \vector{\widetilde{t}}(j), \ \mbox{if}\  j \in  (\bold{ind}(
\vector{\widetilde{t}}) - (\bold{ind}(\vector{\widetilde{t}}) \cap 
\bold{ind}(\vector{\widetilde{c}}))).
\]
where the difference operator in the previous expressions refers to set difference.
\end{itemize}

Finally, the set of output values that make up the $\vector{\widetilde{z}}$ 
vector are written into the column of the final result matrix, 
${\sf C}({\sf row\_index},:)$.  This is carried out under control of the mask 
which acts as a ``write mask''.
\begin{itemize}
    \item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is set then any values in 
    ${\sf C}({\sf row\_index},:)$ on input to {\sf GrB\_assign()} are deleted 
    and the new content of the column is given by:
    \[ 
		\bold{L}({\sf C}) = \{ (i,j,C_{ij}) : i \neq {\sf row\_index} \} \cup \{({\sf row\_index},j,z_{j}) : j \in 
    (\bold{ind}(\vector{\widetilde{z}}) \cap \bold{ind}(\vector{\widetilde{m}})) \}. 
    \]

    \item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is not set, the elements of 
    $\vector{\widetilde{z}}$ indicated by the mask are copied into the column 
    of the final result matrix, ${\sf C}({\sf row\_index},:)$, and elements of 
    this column that fall outside the set indicated by the mask are unchanged:
	\begin{eqnarray} 
		\bold{L}({\sf C}) & = & \{ (i,j,C_{ij}) : i \neq {\sf row\_index} \} \cup \nonumber \\
		& & \{({\sf row\_index},j,\vector{\widetilde{c}}(j)) : j \in (\bold{ind}(\vector{\widetilde{c}}) \cap \bold{ind}(\neg \vector{\widetilde{m}})) \} \cup \nonumber \\ 
		& & \{({\sf row\_index},j,z_{j})                     : j \in (\bold{ind}(\vector{\widetilde{z}}) \cap \bold{ind}(\vector{\widetilde{m}})) \}. \nonumber
	\end{eqnarray}
\end{itemize}

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.


%-----------------------------------------------------------------------------
\subsubsection{{\sf scatter}: Constant vector variant}

Assign the same value to a specified subgraph.  With the use of {\sf GrB\_ALL}, the 
entire destination vector can be filled with the constant.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_scatter(GrB_Vector              w,
                            const GrB_Vector        mask,
                            const GrB_BinaryOp      accum,
                            <type>                  val,
                            const GrB_Index        *indices,
                            const GrB_Index         nindices,
                            const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]    ({\sf INOUT}) An existing GraphBLAS vector.  On input,
    the vector provides values that may be accumulated with the result of the
    assign operation.  On output, this vector holds the results of the
    operation.

    \item[{\sf mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output vector {\sf w}. The 
    mask dimensions must match those of the vector {\sf w} and the domain of the
    {\sf mask} vector must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default vector
    is desired (\ie, with correct dimensions and filled with {\sf true}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]    ({\sf IN}) An optional operator used for accumulating
    entries into existing {\sf w} entries: ${\sf accum} = \langle D_x,
    D_y, D_z,\odot \rangle$. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf val}]      ({\sf IN}) Scalar value to assign to (a subset of) {\sf w}.
    
    \item[{\sf indices}]  ({\sf IN}) Pointer to the ordered set (array) of 
    indices corresponding to the locations in {\sf w} that are to be assigned.  
    If all elements of {\sf w} are to be assigned in order from $0$ to 
    ${\sf nindices} - 1$, then {\sf GrB\_ALL} should be specified.  Regardless of 
    execution mode and return value, this array may be manipulated by the caller
    after this operation returns without affecting any deferred computations for 
    this operation.  In this variant, the specific order of the values in the
    array has no effect on the result.  Unlike other variants, if there are 
    duplicated values in this array the result is still defined.
    
    \item[{\sf nindices}] ({\sf IN}) The number of values in {\sf indices} array.
    Must be in the range: $[0, \bold{size}({\sf w})]$.  If {\sf nindices}
    is zero, the operation becomes a NO-OP.

    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
        {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w} 
        is cleared (all elements removed) before result is stored in it.\\
        
        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural 
        complement of {\sf mask}. \\
    \end{tabular}

\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output vector {\sf w} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]            Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects
    has not been initialized by a call to {\sf new} (or {\sf dup} for vector
    parameters).

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}]  A value in {\sf indices} is greater
    than or equal to $\bold{size}({\sf w})$.  In non-blocking mode, this can be
    reported as an execution error.
    
    \item[{\sf GrB\_DIMENSION\_MISMATCH}] {\sf mask} and {\sf w} dimensions are
    incompatible, or {\sf nindices} is not less than $\bold{size}({\sf w})$. 

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the vector and scalar are
	incompatible with each other or the corresponding domains of the 
    accumulation operator, or the mask's domain is not compatible with {\sf bool}.

    \item[{\sf GrB\_NULL\_POINTER}] Argument {\sf indices} is a {\sf NULL} pointer.
\end{itemize}


\paragraph{Description}

This variant of {\sf GrB\_assign} computes the result of assigning a constant
scalar value to locations in a destination GraphBLAS vector: 
${\sf w}({\sf indices}) = {\sf val}$; or, if an optional binary accumulation 
operator ($\odot$) is provided, 
${\sf w}({\sf indices}) = {\sf w}({\sf indices}) \odot {\sf val}$.  
More explicitly:
\[
\begin{aligned}
	{\sf w}({\sf indices}[i]) = &\ {\sf val}, \ 
    \forall \  i : 0 \leq i < {\sf nindices}, \mbox{~~or~~} \\
    {\sf w}({\sf indices}[i]) = &\ {\sf w}({\sf indices}[i]) \odot {\sf val}, \ 
    \forall \  i : 0 \leq i < {\sf nindices}.
\end{aligned}
\]  
Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[Setup] The internal vectors and mask used in the computation are formed 
and their domains and dimensions are tested for compatibility.
\item[Compute] The indicated computations are carried out.
\item[Output] The result is written into the output vector, possibly under 
control of a mask.
\end{enumerate}

Up to two argument vectors are used in the {\sf GrB\_assign} operation:
\begin{enumerate}
	\item ${\sf w} = \langle \bold{D}({\sf w}),\bold{size}({\sf w}),
    \bold{L}({\sf w}) = \{(i,w_i) \} \rangle$
    
	\item ${\sf mask} = \langle \bold{D}({\sf mask}),\bold{size}({\sf mask}),
    \bold{L}({\sf mask}) = \{(i,m_i) \} \rangle$ (optional)
\end{enumerate}

The argument scalar, vectors, and the accumulation 
operator (if provided) are tested for domain compatibility as follows:
\begin{enumerate}
	\item The domain of {\sf mask} (if not {\sf GrB\_NULL}) must be from one of 
    the pre-defined types of Table~\ref{Tab:PredefinedTypes}.

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be 
    compatible with $\bold{D}({\sf val})$.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be
    compatible with $D_x$ and $D_z$ of the accumulation operator and 
    $\bold{D}({\sf val})$ must be compatible with $D_y$ of the accumulation operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_assign} ends
and the domain mismatch error listed above is returned.

From the arguments, the internal vectors, mask and index array used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Vector $\vector{\widetilde{w}} \leftarrow {\sf w}$.

	\item One-dimensional mask, $\vector{\widetilde{m}}$, is computed from 
    argument {\sf mask} as follows:
	\begin{enumerate}
		\item	If ${\sf mask} = {\sf GrB\_NULL}$, then $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf w}), \{i, \ \forall \ i : 0 \leq i < 
        \bold{size}({\sf w}) \} \rangle$.

		\item	Otherwise, $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf mask}), \{i : i \in \bold{ind}({\sf mask}) \wedge
        ({\sf bool}){\sf mask}(i) = \true \} \rangle$.

		\item	If ${\sf desc[GrB\_MASK].GrB\_SCMP}$ is \true, then 
        $\vector{\widetilde{m}} \leftarrow \neg \vector{\widetilde{m}}$.
	\end{enumerate}

    \item The internal index array, $\grbarray{\widetilde{I}}$, is computed from 
    argument {\sf indices} as follows:
	\begin{enumerate}
		\item	If ${\sf indices} = {\sf GrB\_ALL}$, then 
        $\grbarray{\widetilde{I}}[i] = i, \ \forall \ i : 0 \leq i < {\sf nindices}$.

		\item	Otherwise, $\grbarray{\widetilde{I}}[i] = {\sf indices}[i], 
        \ \forall \ i : 0 \leq i < {\sf nindices}$.
    \end{enumerate}
\end{enumerate}

The internal vector and mask are checked for dimension compatibility. 
The following conditions must hold:
\begin{enumerate}
	\item $\bold{size}(\vector{\widetilde{w}}) = \bold{size}(\vector{\widetilde{m}})$

    \item $0 \leq {\sf nindices} \leq \bold{size}(\vector{\widetilde{w}})$. 
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_assign} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can 
optionally exit with {\sf GrB\_SUCCESS} return code and defer any computation 
and/or execution error codes.

We are now ready to carry out the assign and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
    \item $\vector{\widetilde{t}}$: The vector holding the copies of the scalar 
    {\sf val} in their destination locations relative to 
    $\vector{\widetilde{w}}$.
    
    \item $\vector{\widetilde{z}}$: The vector holding the result after 
    application of the (optional) accumulation.
\end{itemize}

The intermediate vector, $\vector{\widetilde{t}}$, is created as follows:
\[
\vector{\widetilde{t}} = \langle
\bold{D}({\sf val}), \bold{size}(\vector{\widetilde{w}}),
%\bold{L}(\vector{\widetilde{t}}) =
\{(\grbarray{\widetilde{I}}[i],{\sf val})\ \forall \ i,\ 0 \leq i < {\sf nindices} \} \rangle. 
\]
If $\grbarray{\widetilde{I}}$ is empty, this operation results in an empty 
vector, $\vector{\widetilde{t}}$.  Otherwise, if any value in the 
$\grbarray{\widetilde{I}}$ array is not in the range 
$[0,\ \bold{size}(\vector{\widetilde{w}}) )$, the execution of {\sf GrB\_assign} 
ends and the index out-of-bounds error listed above is generated. In 
{\sf GrB\_NONBLOCKING} mode, the error can be deferred until a 
sequence-terminating {\sf GrB\_wait()} is called.  Regardless, the result 
vector, {\sf w}, is invalid from this point forward in the 
sequence.

The intermediate vector $\vector{\widetilde{z}}$ is created as follows:
\begin{itemize}
    \item If ${\sf accum} = {\sf GrB\_NULL}$, then 
    $\vector{\widetilde{z}} = \vector{\widetilde{t}}$.

    \item If ${\sf accum} = \langle D_x, D_y, D_z, \odot \rangle$, then vector 
    $\vector{\widetilde{z}}$ is defined as 
        \[
        \vector{\widetilde{z}} = 
        \langle D_z, \bold{size}(\vector{\widetilde{w}}), 
        %\bold{L}(\vector{\widetilde{z}}) =
		\{(i,z_{i}) \ \forall \ i \in \bold{ind}(\vector{\widetilde{w}}) \cup 
        \bold{ind}(\vector{\widetilde{t}}) \} \rangle.\]
    The values of the elements of $\vector{\widetilde{z}}$ are computed based 
    on the relationships between the sets of indices in $\vector{\widetilde{w}}$ 
    and $\vector{\widetilde{t}}$.
\[
    z_{i} = \vector{\widetilde{w}}(i) \odot \vector{\widetilde{t}}(i), \ \mbox{if}\  
    i \in  (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}})),
\]
\[
    z_{i} = \vector{\widetilde{w}}(i), \ \mbox{if}\  
    i \in  (\bold{ind}(\vector{\widetilde{w}}) - (\bold{ind}(\vector{\widetilde{t}})
    \cap \bold{ind}(\vector{\widetilde{w}}))),
\]
\[
    z_{i} = \vector{\widetilde{t}}(i), \ \mbox{if}\  i \in  
    (\bold{ind}(\vector{\widetilde{t}}) - (\bold{ind}(\vector{\widetilde{t}}) 
    \cap \bold{ind}(\vector{\widetilde{w}}))).
\]
where the difference operator in the previous expressions refers to set difference.
\end{itemize}

Finally, the set of output values that make up the $\vector{\widetilde{z}}$ 
vector are written into the final result vector, ${\sf w}$. 
This is carried out under control of the mask which acts as a ``write mask''.
\begin{itemize}
\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is set then any values in ${\sf w}$ 
on input to {\sf GrB\_assign()} are deleted and the new output vector ${\sf w}$ is,
\[ \bold{L}({\sf w}) = \{(i,z_{i}) : i \in (\bold{ind}(\vector{\widetilde{z}}) 
\cap \bold{ind}(\vector{\widetilde{m}})) \}. \]

\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is not set, the elements of 
$\vector{\widetilde{z}}$ indicated by 
the mask are copied into the result vector, ${\sf w}$, and elements of 
${\sf w}$ that fall outside the set indicated by the mask are unchanged:
\[ \bold{L}({\sf w}) = \{(i,w_{i}) : i \in (\bold{ind}(\vector{\sf w}) 
\cap \bold{ind}(\neg \vector{\widetilde{m}})) \} \cup \{(i,z_{i}) : i \in 
(\bold{ind}(\vector{\widetilde{z}}) \cap \bold{ind}(\vector{\widetilde{m}})) \}. \]
\end{itemize}

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.



%-----------------------------------------------------------------------------
\subsubsection{{\sf scatter}: Constant matrix variant}

Assign the same value to a specified subgraph.  With the use of {\sf GrB\_ALL}, 
the entire destination matrix can be filled with the constant.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_scatter(GrB_Matrix              C,
                            const GrB_Matrix        Mask,
                            const GrB_BinaryOp      accum,
                            <type>                  val,
                            const GrB_Index        *row_indices,
                            const GrB_Index         nrows,
                            const GrB_Index        *col_indices,
                            const GrB_Index         ncols,
                            const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    ({\sf INOUT}) An existing GraphBLAS Matrix.  On input,
    the matrix provides values that may be accumulated with the result of the
    assign operation.  On output, this matrix holds the results of the
    operation.

    \item[{\sf Mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output matrix {\sf C}. The 
    mask dimensions must match those of the matrix {\sf C} and the domain of the 
    {\sf Mask} matrix must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    matrix is desired (\ie, with correct dimensions and filled with {\sf true}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]    ({\sf IN}) An optional operator used for accumulating
    entries into existing {\sf C} entries: ${\sf accum} = \langle D_x,
    D_y, D_z,\odot \rangle$. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf val}]    ({\sf IN}) Scalar value to assign to (a subset of) {\sf C}.
    
    \item[{\sf row\_indices}]  ({\sf IN}) Pointer to the ordered set (array) of 
    indices corresponding to the rows of {\sf C} that are assigned.  If all rows
    of {\sf C} are to be assigned in order from $0$ to ${\sf nrows} - 1$, then 
    {\sf GrB\_ALL} can be specified.  Regardless of execution mode and return 
    value, this array may be manipulated by the caller after this operation 
    returns without affecting any deferred computations for this operation.  
    Unlike other variants, if there are duplicated values in this array the 
    result is still defined.

    \item[{\sf nrows}] ({\sf IN}) The number of values in {\sf row\_indices} 
	array. Must be in the range: $[0, \bold{nrows}({\sf C})]$.  If
    {\sf nrows} is zero, the operation becomes a NO-OP.

    \item[{\sf col\_indices}]  ({\sf IN}) Pointer to the ordered set (array) of 
    indices corresponding to the columns of {\sf C} that are assigned.  If all columns
    of {\sf C} are to be assigned in order from $0$ to ${\sf ncols} - 1$, then 
    {\sf GrB\_ALL} can be specified.  Regardless of execution mode and return 
    value, this array may be manipulated by the caller after this operation 
    returns without affecting any deferred computations for this operation.
    Unlike other variants, if there are duplicated values in this array the 
    result is still defined.

    \item[{\sf ncols}] ({\sf IN}) The number of values in {\sf col\_indices} 
	array. Must be in the range: $[0, \bold{ncols}({\sf C})]$.  If
    {\sf ncols} is zero, the operation becomes a NO-OP.

    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
        {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C} 
        is cleared (all elements removed) before result is stored in it.\\
    
        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP} & Use the structural 
        complement of {\sf Mask}. \\
    \end{tabular}

\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output matrix {\sf C} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]            Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects
    has not been initialized by a call to {\sf new} (or {\sf dup} for vector
    parameters).

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}]  A value in {\sf row\_indices} is greater
    than or equal to $\bold{nrows}({\sf C})$, or a value in {\sf col\_indices} is greater
    than or equal to $\bold{ncols}({\sf C})$.  In non-blocking mode, this can be
    reported as an execution error.

    \item[{\sf GrB\_DIMENSION\_MISMATCH}]  {\sf Mask} and {\sf C} dimensions are
    incompatible, {\sf nrows} is not less than $\bold{nrows}({\sf C})$, or
    {\sf ncols} is not less than $\bold{ncols}({\sf C})$. 

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]     The domains of the matrix and scalar are
	incompatible with each other or the corresponding domains of the 
    accumulation operator, or the mask's domain is not compatible with {\sf bool}.

    \item[{\sf GrB\_NULL\_POINTER}] Either argument {\sf row\_indices} is a {\sf NULL} pointer,
	    argument {\sf col\_indices} is a {\sf NULL} pointer, or both.
\end{itemize}


\paragraph{Description}


This variant of {\sf GrB\_assign} computes the result of assigning a constant
scalar value to locations in a destination GraphBLAS matrix: 
${\sf C}({\sf row\_indices, col\_indices}) = {\sf val}$; or, if an optional 
binary accumulation operator ($\odot$) is provided, 
${\sf C}({\sf row\_indices, col\_indices}) = 
{\sf w}({\sf row\_indices, col\_indices}) \odot {\sf val}$.  
More explicitly:
\[
\begin{aligned}
	{\sf C}({\sf row\_indices}[i], {\sf col\_indices}[j]) =\ & {\sf val} \mbox{~~or~~} \\
    {\sf C}({\sf row\_indices}[i], {\sf col\_indices}[j]) =\ & 
              {\sf C}({\sf row\_indices}[i], {\sf col\_indices}[j]) \odot {\sf val} \\
    & \forall \ (i,j) \ : \ 0 \leq i < {\sf nrows},  0 \leq j < {\sf ncols}
\end{aligned}
\]  
Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[Setup] The internal vectors and mask used in the computation are formed 
and their domains and dimensions are tested for compatibility.
\item[Compute] The indicated computations are carried out.
\item[Output] The result is written into the output matrix, possibly under 
control of a mask.
\end{enumerate}

Up to two argument matrices are used in the {\sf GrB\_assign} operation:
\begin{enumerate}
	\item ${\sf C} = \langle \bold{D}({\sf C}),\bold{nrows}({\sf C}),
    \bold{ncols}({\sf C}),\bold{L}({\sf C}) = \{(i,j,C_{ij}) \} \rangle$
    
	\item ${\sf Mask} = \langle \bold{D}({\sf Mask}),\bold{nrows}({\sf Mask}),
    \bold{ncols}({\sf Mask}),\bold{L}({\sf Mask}) = \{(i,j,M_{ij}) \} \rangle$ (optional)
\end{enumerate}

The argument scalar, matrices, and the accumulation 
operator (if provided) are tested for domain compatibility as follows:
\begin{enumerate}
	\item The domain of {\sf Mask} (if not {\sf GrB\_NULL}) must be from one of 
    the pre-defined types of Table~\ref{Tab:PredefinedTypes}.

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be 
    compatible with $\bold{D}({\sf val})$.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be
    compatible with $D_x$ and $D_z$ of the accumulation operator and 
    $\bold{D}({\sf val})$ must be compatible with $D_y$ of the accumulation operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_assign} ends
and the domain mismatch error listed above is returned.

From the arguments, the internal matrices, index arrays, and mask used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Matrix $\matrix{\widetilde{C}} \leftarrow {\sf C}$.

	\item Two-dimensional mask $\matrix{\widetilde{M}}$ is computed from 
    argument {\sf Mask} as follows:
	\begin{enumerate}

		\item	If ${\sf Mask} = {\sf GrB\_NULL}$, then $\matrix{\widetilde{M}} = 
        \langle \bold{nrows}({\sf C}), \bold{ncols}({\sf C}), \{(i,j), 
        \forall i,j : 0 \leq i <  \bold{nrows}({\sf C}), 0 \leq j < 
        \bold{ncols}({\sf C}) \} \rangle$.

		\item	Otherwise, $\matrix{\widetilde{M}} = \langle 
        \bold{nrows}({\sf Mask}), \bold{ncols}({\sf Mask}), \{(i,j) : 
        (i,j) \in \bold{ind}({\sf Mask}) \wedge 
        ({\sf bool}){\sf Mask}(i,j) = \true\} \rangle$.

		\item	If ${\sf desc[GrB\_MASK].GrB\_SCMP}$ is set, then 
        $\matrix{\widetilde{M}} \leftarrow \neg \matrix{\widetilde{M}}$.
	\end{enumerate}

    \item The internal row index array, $\grbarray{\widetilde{I}}$, is computed from 
    argument {\sf row\_indices} as follows:
	\begin{enumerate}
		\item	If ${\sf row\_indices} = {\sf GrB\_ALL}$, then 
        $\grbarray{\widetilde{I}}[i] = i, \forall i : 0 \leq i < {\sf nrows}$.

		\item	Otherwise, $\grbarray{\widetilde{I}}[i] = {\sf row\_indices}[i], 
        \forall i : 0 \leq i < {\sf nrows}$.
    \end{enumerate}
    
    \item The internal column index array, $\grbarray{\widetilde{J}}$, is computed from 
    argument {\sf col\_indices} as follows:
	\begin{enumerate}
		\item	If ${\sf col\_indices} = {\sf GrB\_ALL}$, then 
        $\grbarray{\widetilde{J}}[j] = j, \forall j : 0 \leq j < {\sf ncols}$.

		\item	Otherwise, $\grbarray{\widetilde{J}}[j] = {\sf col\_indices}[j], 
        \forall j : 0 \leq j < {\sf ncols}$.
    \end{enumerate}
\end{enumerate}

The internal matrix and mask are checked for dimension compatibility. 
The following conditions must hold:
\begin{enumerate}
    \item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{M}})$.

    \item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{M}})$.

    \item $0 \leq {\sf nrows} \leq \bold{nrows}(\matrix{\widetilde{C}})$.

    \item $0 \leq {\sf ncols} \leq \bold{ncols}(\matrix{\widetilde{C}})$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_assign} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can 
optionally exit with {\sf GrB\_SUCCESS} return code and defer any computation 
and/or execution error codes.

We are now ready to carry out the assign and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
	\item $\matrix{\widetilde{T}}$: The matrix holding the copies of the scalar 
    {\sf val} in their destination locations relative to 
    $\matrix{\widetilde{C}}$.
    
	\item $\matrix{\widetilde{Z}}$: The matrix holding the result after 
    application of the (optional) accumulation operator.
\end{itemize}

The intermediate matrix, $\matrix{\widetilde{T}}$, is created as follows:
\[
\begin{aligned}
\matrix{\widetilde{T}} = \langle & \bold{D}({\sf val}),
                           \bold{nrows}(\matrix{\widetilde{C}}), 
                           \bold{ncols}(\matrix{\widetilde{C}}), \\
 & \{ (\grbarray{\widetilde{I}}[i],\grbarray{\widetilde{J}}[j], {\sf val}) 
 \ \forall \ (i,j), \ 0 \leq i < {\sf nrows}, \ 0 \leq j < {\sf ncols} \} \rangle. 
\end{aligned}
\]
If either $\grbarray{\widetilde{I}}$ or $\grbarray{\widetilde{J}}$ is empty, this 
operation results in an empty matrix, $\matrix{\widetilde{T}}$.  Otherwise, if 
any value in the $\grbarray{\widetilde{I}}$ array is not in
the range $[0,\ \bold{nrows}(\matrix{\widetilde{C}}) )$ or any value in the 
$\grbarray{\widetilde{J}}$ array is not in the range 
$[0,\ \bold{ncols}(\matrix{\widetilde{C}}))$, the execution of {\sf GrB\_assign} 
ends and the index out-of-bounds error listed above is generated. In 
{\sf GrB\_NONBLOCKING} mode, the error can be deferred until a 
sequence-terminating {\sf GrB\_wait()} is called.  Regardless, the result 
matrix {\sf C} is invalid from this point forward in the sequence.

The intermediate matrix $\matrix{\widetilde{Z}}$ is created as follows:
\begin{itemize}
    \item If ${\sf accum} = {\sf GrB\_NULL}$, then 
    $\matrix{\widetilde{Z}} = \matrix{\widetilde{T}}$.

    \item If ${\sf accum} = \langle D_x, D_y, D_z, \odot \rangle$, then matrix 
    $\matrix{\widetilde{Z}}$ is defined as 
        \[ 
        \matrix{\widetilde{Z}} = 
        \langle D_z, \bold{nrows}(\matrix{\widetilde{C}}),
        \bold{ncols}(\matrix{\widetilde{C}}), 
        %\bold{L}(\matrix{\widetilde{Z}}) =
	    \{(i,j,Z_{ij}) \ \forall \ (i,j) \in \bold{ind}(\matrix{\widetilde{C}}) \cup 
        \bold{ind}(\matrix{\widetilde{T}}) \} \rangle.\]
    The values of the elements of $\matrix{\widetilde{Z}}$ are computed based on 
    the relationships between the sets of indices in $\matrix{\widetilde{C}}$ and 
    $\matrix{\widetilde{T}}$.
\[
	Z_{ij} = \matrix{\widetilde{C}}(i,j) \odot \matrix{\widetilde{T}}(i,j), 
    \mbox{~if~} (i,j) \in  (\bold{ind}(\matrix{\widetilde{T}}) \cap 
    \bold{ind}(\matrix{\widetilde{C}})),
\]
\[
	Z_{ij} = \matrix{\widetilde{C}}(i,j), \mbox{~if~} (i,j) \in  
    (\bold{ind}(\matrix{\widetilde{C}}) - (\bold{ind}(\matrix{\widetilde{T}}) \cap 
    \bold{ind}(\matrix{\widetilde{C}}))),
\]
\[
	Z_{ij} = \matrix{\widetilde{T}}(i,j), \mbox{~if~} (i,j) \in  
    (\bold{ind}(\matrix{\widetilde{T}}) - (\bold{ind}(\matrix{\widetilde{T}}) \cap 
    \bold{ind}(\matrix{\widetilde{C}}))).
\]
where the difference operator in the previous expressions refers to set difference.
\end{itemize}

Finally, the set of output values that make up the $\matrix{\widetilde{Z}}$ 
matrix are written into the final result matrix, ${\sf C}$. 
This is carried out under control of the mask which acts as a ``write mask''.
\begin{itemize}
\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is set then any values in ${\sf C}$ 
on input to {\sf GrB\_assign()} are deleted and the new output matrix ${\sf C}$ is,
		\[ \bold{L}({\sf C}) = \{(i,j,Z_{ij}) : (i,j) \in (\bold{ind}(\matrix{\widetilde{Z}}) 
\cap \bold{ind}(\matrix{\widetilde{M}})) \}. \]

\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is not set, the elements of 
$\matrix{\widetilde{Z}}$ indicated by 
the mask are copied into the result matrix, ${\sf C}$, and elements of 
${\sf C}$ that fall outside the set indicated by the mask are unchanged:
		\[ \bold{L}({\sf C}) = \{(i,j,C_{ij}) : (i,j) \in (\bold{ind}(\matrix{\sf C}) 
		\cap \bold{ind}(\neg \matrix{\widetilde{M}})) \} \cup \{(i,j,Z_{ij}) : (i,j) \in 
(\bold{ind}(\matrix{\widetilde{Z}}) \cap \bold{ind}(\matrix{\widetilde{M}})) \}. \]
\end{itemize}

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of matrix {\sf C} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of matrix {\sf C} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.
